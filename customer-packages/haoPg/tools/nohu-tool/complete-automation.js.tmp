/**
 * Complete Automation - All automation workflows
 * Handles: Register, Login, Add Bank, Check Promotion
 */

const puppeteer = require('puppeteer-core');
const AutomationActions = require('./automation-actions');

// Helper function to replace deprecated page.then(() => wait()
async function wait(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

class CompleteAutomation {
    constructor(settings, scripts) {
        this.settings = settings;
        this.scripts = scripts; // { contentScript, captchaSolver, banksScript }
    }

    /**
     * Inject all extension scripts into page (with duplicate check)
     */
    async injectScripts(page) {
        // Check if scripts already injected
        const alreadyInjected = await page.evaluate(() => {
            return window.autoRegisterToolLoaded === true;
        });

        if (alreadyInjected) {
            console.log('    ‚úÖ Scripts already injected, skipping...');
            return;
        }

        console.log('    üíâ Injecting chrome.runtime mock...');
        await page.evaluate(() => {
            if (!window.chrome) window.chrome = {};
            if (!window.chrome.runtime) {
                window.chrome.runtime = {
                    sendMessage: async (message, callback) => {
                        console.log('üì§ Mock sendMessage:', message);

                        // Handle API calls (for captcha solving)
                        if (message.action === 'apiCall') {
                            try {
                                console.log('üåê Proxying API call:', message.data.endpoint);

                                const response = await fetch(message.data.endpoint, {
                                    method: message.data.method || 'GET',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    },
                                    body: message.data.body ? JSON.stringify(message.data.body) : undefined
                                });

                                const result = await response.json();
                                console.log('‚úÖ API call successful:', result);

                                if (callback) callback({ success: true, data: result });
                            } catch (error) {
                                console.error('‚ùå API call failed:', error);
                                if (callback) callback({ success: false, error: error.message });
                            }
                        } else {
                            // Other messages
                            if (callback) callback({ success: true });
                        }
                    },
                    onMessage: {
                        addListener: (callback) => {
                            console.log('üì• Mock onMessage listener added');
                            window._chromeMessageListener = callback;
                        }
                    },
                    lastError: null
                };
            }
        });

        console.log('    üíâ Injecting banks.js...');
        await page.evaluate(this.scripts.banksScript);

        console.log('    üíâ Injecting captcha-solver.js...');
        await page.evaluate(this.scripts.captchaSolver);

        console.log('    üíâ Injecting Puppeteer API helper (bypass CORS)...');
        // Check if already exposed to avoid "already exists" error
        const hasApiCall = await page.evaluate(() => typeof window.__puppeteerApiCall === 'function');

        if (!hasApiCall) {
            await page.exposeFunction('__puppeteerApiCall', async (endpoint, method, body, apiKey) => {
                const axios = require('axios');
                console.log(`üåê [Node.js] API Call: ${method} ${endpoint}`);

                try {
                    const response = await axios({
                        method: method,
                        url: endpoint,
                        data: body,
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        timeout: 30000
                    });

                    console.log(`‚úÖ [Node.js] API Response:`, response.data);
                    return response.data;
                } catch (error) {
                    console.error(`‚ùå [Node.js] API Error:`, error.message);
                    throw new Error(error.response?.data?.message || error.message);
                }
            });
            console.log('    ‚úÖ API helper exposed');
        } else {
            console.log('    ‚ôªÔ∏è  API helper already exists, skipping');
        }

        console.log('    üíâ Injecting content.js (FULL LOGIC)...');
        await page.evaluate(this.scripts.contentScript);
    }

    /**
     * Verify scripts loaded successfully
     */
    async verifyScripts(page) {
        console.log('    üîç Verifying scripts loaded...');
        const scriptsLoaded = await page.evaluate(() => {
            return {
                autoRegisterToolLoaded: window.autoRegisterToolLoaded === true,
                listenerExists: typeof window._chromeMessageListener === 'function'
            };
        });

        console.log('    üìä Scripts status:', scriptsLoaded);

        if (!scriptsLoaded.listenerExists) {
            console.log('    ‚ö†Ô∏è  Message listener not registered yet, waiting 5 more seconds...');
            await page.then(() => wait(5000);

            const recheckListener = await page.evaluate(() => {
                return typeof window._chromeMessageListener === 'function';
            });

            if (!recheckListener) {
                throw new Error('Content script failed to initialize');
            }

            console.log('    ‚úÖ Message listener now available');
        }

        return scriptsLoaded;
    }

    /**
     * Setup page with scripts (with smart loading detection)
     */
    async setupPage(browser, url) {
        const page = await browser.newPage();

        console.log('    üìÑ Opening page...');
        await page.goto(url, { waitUntil: 'domcontentloaded', timeout: 60000 });

        // Focus on tab once to avoid throttling
        console.log('    üëÅÔ∏è  Focusing on tab to avoid throttling...');
        await page.bringToFront();

        console.log('    ‚è≥ Waiting for page to fully load (smart detection)...');

        // Wait for document.readyState === 'complete' with timeout
        try {
            await page.waitForFunction(() => document.readyState === 'complete', { timeout: 20000 });
            console.log('    ‚úÖ Page loaded (document.readyState = complete)');
        } catch (e) {
            console.log('    ‚ö†Ô∏è  Timeout waiting for complete state, checking if page is usable...');
        }

        // Additional wait for UI to render (but shorter since we already waited)
        console.log('    ‚è≥ Waiting 5 seconds for UI to render...');
        await page.then(() => wait(5000);

        await this.injectScripts(page);

        console.log('    ‚è≥ Waiting for scripts to initialize...');
        await page.then(() => wait(3000);

        await this.verifyScripts(page);

        return page;
    }

    /**
     * 1. Complete Registration
     */
    async runRegistration(browser, url, profileData) {
        const page = await this.setupPage(browser, url);

        try {
            const actions = new AutomationActions(page);
            const result = await actions.completeRegistration(profileData);

            console.log('    ‚ÑπÔ∏è  Keeping page open for inspection...');
            return result;

        } catch (error) {
            console.error('    ‚ùå Error:', error.message);
            return { success: false, message: error.message };
        }
    }

    /**
     * 2. Complete Login
     */
    async runLogin(browserOrContext, url, profileData) {
        // Support both browser and browserContext
        const page = await this.setupPage(browserOrContext, url);

        try {
            // Send message to content script to login
            console.log('    üì§ Sending login message to content script...');

            // Trigger login (will cause navigation)
            await page.evaluate((profileData) => {
                if (window._chromeMessageListener) {
                    window._chromeMessageListener(
                        {
                            action: 'autoLogin',
                            data: profileData
                        },
                        {},
                        () => { } // Don't wait for response, page will navigate
                    );
                }
            }, profileData);

            console.log('    ‚è≥ Waiting for login navigation...');

            // Wait for navigation (login redirect)
            try {
                await page.waitForNavigation({ waitUntil: 'networkidle2', timeout: 30000 });
                console.log('    ‚úÖ Navigation completed');
            } catch (e) {
                console.log('    ‚ö†Ô∏è Navigation timeout, checking current URL...');
            }

            // Check if login successful (URL changed from login page)
            const currentUrl = page.url();
            const isStillOnLoginPage = currentUrl.includes('/login') || currentUrl.includes('dang-nhap');

            if (isStillOnLoginPage) {
                console.log('    ‚ùå Still on login page, login may have failed');
                return { success: false, message: 'Still on login page' };
            }

            console.log('    ‚úÖ Redirected to:', currentUrl);

            // Check for token to confirm login success
            console.log('    üîç Checking for login token...');
            const hasToken = await page.evaluate(() => {
                const cookies = document.cookie;
                const hasAuthToken = cookies.includes('token=') ||
                    cookies.includes('auth=') ||
                    cookies.includes('session=') ||
                    cookies.includes('access_token=');

                const hasLocalStorage = localStorage.getItem('token') ||
                    localStorage.getItem('auth') ||
                    localStorage.getItem('access_token');

                return hasAuthToken || hasLocalStorage;
            });

            if (hasToken) {
                console.log('    ‚úÖ Login token found - Login successful!');
            } else {
                console.log('    ‚ö†Ô∏è No token found, but redirected from login page');
            }

            console.log('    ‚ÑπÔ∏è  Keeping page open for inspection...');

            return {
                success: true,
                message: 'Login completed',
                hasToken: hasToken,
                result: { submitted: true }
            };

        } catch (error) {
            console.error('    ‚ùå Error:', error.message);
            return { success: false, message: error.message };
        }
    }

    /**
     * 3. Complete Add Bank
     */
    async runAddBank(browser, url, bankInfo) {
        const page = await this.setupPage(browser, url);

        try {
            // Send message to content script to add bank
            console.log('    üì§ Sending addBank message to content script...');
            const result = await page.evaluate((bankInfo) => {
                return new Promise((resolve) => {
                    if (window._chromeMessageListener) {
                        window._chromeMessageListener(
                            {
                                action: 'redirectToWithdrawAndFill',
                                data: { withdrawInfo: bankInfo }
                            },
                            {},
                            (response) => {
                                resolve(response);
                            }
                        );
                    } else {
                        resolve({ success: false, message: 'Content script not loaded' });
                    }
                });
            }, bankInfo);

            console.log('    ‚ÑπÔ∏è  Keeping page open for inspection...');
            return result;

        } catch (error) {
            console.error('    ‚ùå Error:', error.message);
            return { success: false, message: error.message };
        }
    }

    /**
     * 3b. Complete Add Bank in existing context (reuse login page)
     */
    async runAddBankInContext(browserContext, url, bankInfo) {
        // Get existing pages in context
        const pages = await browserContext.pages();

        // Find the login page for this URL (same domain)
        const loginDomain = new URL(url).hostname;
        let page = pages.find(p => {
            try {
                return new URL(p.url()).hostname === loginDomain;
            } catch {
                return false;
            }
        });

        // If not found, create new page in context
        if (!page) {
            console.log('    üìÑ Creating new page in shared context...');
            page = await browserContext.newPage();
            await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
            await page.then(() => wait(3000);
            await this.injectScripts(page);
            await page.then(() => wait(3000);
            await this.verifyScripts(page);
        } else {
            console.log('    ‚ôªÔ∏è  Reusing existing login page in shared context...');
            console.log(`    üìç Current URL: ${page.url()}`);

            // After login, page has navigated to dashboard/home
            // Scripts are ALWAYS lost after navigation, so re-inject them
            console.log('    üíâ Re-injecting scripts (required after login navigation)...');

            try {
                await this.injectScripts(page);
                console.log('    ‚è≥ Waiting for scripts to initialize...');
                await page.then(() => wait(3000);
                await this.verifyScripts(page);
                console.log('    ‚úÖ Scripts ready for add bank operation');
            } catch (error) {
                console.error('    ‚ùå Script injection failed:', error.message);
                throw error;
            }

            // Don't manually navigate - let content.js handle it via redirectToWithdrawAndFill
            // This way, content.js can properly handle the navigation and form filling
            console.log('    ‚ÑπÔ∏è  Will use redirectToWithdrawAndFill action to navigate and fill');
        }

        try {
            // Send message to content script to add bank
            console.log('    üì§ Sending addBank message to content script...');

            // Add timeout to prevent hanging
            const result = await Promise.race([
                page.evaluate((bankInfo) => {
                    return new Promise((resolve) => {
                        if (window._chromeMessageListener) {
                            // Set timeout inside evaluate (increased for bank form filling)
                            const timeout = setTimeout(() => {
                                console.log('‚è±Ô∏è Add bank timeout after 60s');
                                resolve({ success: true, message: 'Add bank timeout (may still be processing)' });
                            }, 60000);

                            window._chromeMessageListener(
                                {
                                    action: 'redirectToWithdrawAndFill',
                                    data: { withdrawInfo: bankInfo }
                                },
                                {},
                                (response) => {
                                    clearTimeout(timeout);
                                    resolve(response);
                                }
                            );
                        } else {
                            resolve({ success: false, message: 'Content script not loaded' });
                        }
                    });
                }, bankInfo),
                new Promise((resolve) => setTimeout(() => {
                    console.log('‚è±Ô∏è Add bank operation timeout (65s)');
                    resolve({ success: true, message: 'Add bank operation timeout (may still be processing)' });
                }, 65000))
            ]);

            console.log('    üìä Add bank result:', result);

            // Wait for bank form to be filled and submitted (like tool c≈©)
            console.log('    ‚è≥ Waiting 25 seconds for bank form to be filled and submitted...');
            await page.then(() => wait(25000);

            console.log('    ‚úÖ Add bank process completed');
            console.log('    ‚ÑπÔ∏è  Keeping page open in shared context...');
            return { success: true, message: 'Bank added successfully' };

        } catch (error) {
            console.error('    ‚ùå Error:', error.message);
            return { success: false, message: error.message };
        }
    }

    /**
     * 4. Complete Check Promotion
     */
    async runCheckPromotion(browser, url, username, apiKey) {
        const page = await this.setupPage(browser, url);

        try {
            const actions = new AutomationActions(page);
            const result = await actions.completeCheckPromotion(username, apiKey);

            console.log('    ‚ÑπÔ∏è  Keeping page open for inspection...');
            return result;

        } catch (error) {
            console.error('    ‚ùå Error:', error.message);
            return { success: false, promotions: [], message: error.message };
        }
    }

    /**
     * 4b. Check Promotion from Login Context (like extension - duplicate login tab)
     */
    async runCheckPromotionFromLogin(browserContext, promoUrl, loginUrl, username, apiKey) {
        console.log('    üéÅ Checking promotion from logged-in context...');

        // Get existing pages in context
        const pages = await browserContext.pages();

        // Find the login page (already logged in)
        const loginDomain = new URL(loginUrl).hostname;
        const loginPage = pages.find(p => {
            try {
                return new URL(p.url()).hostname === loginDomain;
            } catch {
                return false;
            }
        });

        if (!loginPage) {
            console.log('    ‚ùå No login page found in context');
            return { success: false, promotions: [], message: 'No login page found' };
        }

        console.log('    üìã Creating new page for promo check (like extension duplicate)...');
        const promoPage = await browserContext.newPage();

        // Navigate to promo URL
        console.log(`    üéÅ Navigating to promo URL: ${promoUrl}`);
        await promoPage.goto(promoUrl, { waitUntil: 'networkidle2', timeout: 30000 });
        await promoPage.then(() => wait(3000);

        // Inject scripts
        console.log('    üíâ Injecting scripts...');
        await this.injectScripts(promoPage);
        await promoPage.then(() => wait(2000);
        await this.verifyScripts(promoPage);

        try {
            // Simple check: just scan for promotions, don't auto-click or solve captcha
            console.log('    üîç Scanning page for promotions...');
            const promotions = await promoPage.evaluate(() => {
                // Simple scan for promo keywords
                const promoKeywords = ['khuy·∫øn m√£i', 'khuyen mai', 'promotion', 'bonus', 'th∆∞·ªüng'];
                const promotions = [];
                const allElements = document.querySelectorAll('*');

                allElements.forEach(el => {
                    const text = el.textContent.trim();
                    if (text.length > 5 && text.length < 200) {
                        const lowerText = text.toLowerCase();
                        const hasPromoKeyword = promoKeywords.some(keyword => lowerText.includes(keyword));
                        if (hasPromoKeyword && /\d+/.test(text)) {
                            if (!promotions.includes(text)) {
                                promotions.push(text);
                            }
                        }
                    }
                });

                return promotions.slice(0, 10);
            });

            console.log(`    ‚úÖ Found ${promotions.length} promotions`);
            console.log('    ‚ÑπÔ∏è  Keeping promo page open for inspection...');

            return { success: true, promotions, message: `Found ${promotions.length} promotions` };

        } catch (error) {
            console.error('    ‚ùå Error:', error.message);
            return { success: false, promotions: [], message: error.message };
        }
    }

    /**
     * 4c. Check Promotion FULL (like extension - auto-click and solve captcha)
     */
    async runCheckPromotionFull(promoContext, loginContext, promoUrl, loginUrl, username, apiKey) {
        console.log('    üéÅ Running FULL check promotion (auto-click + captcha)...');

        // Create new page in promo context
        console.log('    üìã Creating new page in promo context...');
        const promoPage = await promoContext.newPage();

        // Setup request interceptor to capture audio URL directly from requests
        console.log('    üåê Setting up network request interceptor for audio URL...');
        promoPage.on('request', async (request) => {
            const url = request.url();
            // Check if this is a direct audio file request
            if (url.includes('audio-captcha-cache') && url.endsWith('.mp3')) {
                const audioUrl = url.replace('http://', 'https://');
                console.log('    üéµ üî• CAPTURED AUDIO URL FROM NETWORK REQUEST:', audioUrl);

                // Solve captcha from Node.js side (avoid CORS issues)
                setTimeout(async () => {
                    try {
                        console.log('    üîê Solving audio captcha from Node.js...');
                        const axios = require('axios');

                        // Call captcha solving API
                        const solveResponse = await axios.post('https://api.captchaai.io/audio_to_text', {
                            audio_url: audioUrl,
                            apikey: apiKey
                        }, {
                            timeout: 30000
                        });

                        if (solveResponse.data && solveResponse.data.text) {
                            const captchaText = solveResponse.data.text;
                            console.log('    ‚úÖ Captcha solved:', captchaText);

                            // Inject captcha text into page
                            await promoPage.evaluate((text) => {
                                console.log('üíâ Filling captcha input with:', text);
                                // Find captcha input and fill it
                                const inputs = document.querySelectorAll('input[type="text"], input:not([type])');
                                for (const input of inputs) {
                                    const placeholder = (input.placeholder || '').toLowerCase();
                                    const label = input.labels?.[0]?.textContent?.toLowerCase() || '';
                                    if (placeholder.includes('captcha') || placeholder.includes('x√°c th·ª±c') ||
                                        label.includes('captcha') || label.includes('x√°c th·ª±c') ||
                                        input.name?.toLowerCase().includes('captcha')) {
                                        input.value = text;
                                        input.dispatchEvent(new Event('input', { bubbles: true }));
                                        input.dispatchEvent(new Event('change', { bubbles: true }));
                                        console.log('‚úÖ Captcha filled into input');

                                        // Click submit button
                                        setTimeout(() => {
                                            const submitBtn = document.querySelector('button.submit-btn, button[type="submit"]');
                                            if (submitBtn) {
                                                submitBtn.click();
                                                console.log('‚úÖ Submit button clicked');
                                            }
                                        }, 500);
                                        break;
                                    }
                                }
                            }, captchaText);
                        } else {
                            console.error('    ‚ùå Failed to solve captcha:', solveResponse.data);
                        }
                    } catch (e) {
                        console.error('    ‚ùå Error solving captcha:', e.message);
                    }
                }, 1000);
            }
        });

        // Also setup response interceptor as backup
        console.log('    üåê Setting up network response interceptor for audio URL...');
        promoPage.on('response', async (response) => {
            const url = response.url();
            // Check if response contains audio URL
            if (url.includes('admin-ajax.php')) {
                console.log('    üì° Intercepted admin-ajax.php response');
                try {
                    const text = await response.text();
                    console.log('    üìÑ Response length:', text.length, 'chars');

                    // Try multiple patterns to find audio URL
                    const patterns = [
                        /http[s]?:\/\/[^\s"']+audio-captcha-cache[^\s"']+\.mp3/i,
                        /http[s]?:\/\/[^\s"'<>]+\.mp3/i,
                        /"audio_url":\s*"([^"]+)"/i,
                        /'audio_url':\s*'([^']+)'/i
                    ];

                    let audioUrl = null;
                    for (const pattern of patterns) {
                        const match = text.match(pattern);
                        if (match) {
                            audioUrl = match[1] || match[0];
                            console.log('    ‚úÖ Found audio URL with pattern:', pattern);
                            break;
                        }
                    }

                    if (audioUrl) {
                        audioUrl = audioUrl.replace('http://', 'https://');
                        console.log('    üéµ üî• CAPTURED AUDIO URL FROM NETWORK:', audioUrl);
                        // Inject audio URL into page
                        await promoPage.evaluate((url) => {
                            console.log('üíâ Injecting audio URL into page:', url);
                            if (typeof addAudioUrl === 'function') {
                                addAudioUrl(url);
                            } else {
                                console.error('‚ùå addAudioUrl function not found!');
                            }
                        }, audioUrl);
                    } else {
                        console.log('    ‚ö†Ô∏è  No audio URL found in response');
                        // Log first 200 chars of response for debugging
                        console.log('    üìù Response preview:', text.substring(0, 200));
                    }
                } catch (e) {
                    console.error('    ‚ùå Error processing response:', e.message);
                }
            }
        });

        // Navigate to promo URL
        console.log(`    üéÅ Navigating to promo URL: ${promoUrl}`);
        await promoPage.goto(promoUrl, { waitUntil: 'networkidle2', timeout: 30000 });
        await promoPage.then(() => wait(3000);

        // Inject scripts
        console.log('    üíâ Injecting scripts...');
        await this.injectScripts(promoPage);
        await promoPage.then(() => wait(3000);
        await this.verifyScripts(promoPage);

        try {
            // Use FULL checkPromotion action (auto-click and solve captcha)
            console.log('    üéÅ Starting FULL promotion check workflow...');
            console.log('    üìä Creating AutomationActions instance...');
            const actions = new AutomationActions(promoPage);
            console.log('    ‚úÖ AutomationActions created');

            console.log('    üìû Calling completeCheckPromotion...');
            console.log('    üìä Username:', username);
            console.log('    üìä API Key:', apiKey ? `${apiKey.substring(0, 5)}...` : 'undefined');

            const result = await actions.completeCheckPromotion(username, apiKey);

            console.log('    üìä Check promo result:', result);
            console.log('    ‚úÖ Check promo completed - captcha solved');

            // Wait for button click and response
            console.log('    ‚è≥ Waiting for "Nh·∫≠n khuy·∫øn m√£i" button to be clicked...');

            // Wait a bit for button to be clicked
            await promoPage.then(() => wait(2000);

            // Check if button was clicked (optional check)
            const clickSuccess = await promoPage.evaluate(() => {
                return window.promoButtonClickedSuccess === true;
            });

            if (clickSuccess) {
                console.log('    ‚úÖ Button click confirmed via flag');
            } else {
                console.log('    ‚ö†Ô∏è  Button click flag not set, but continuing to screenshot...');
            }

            // Always try to take screenshot after completeCheckPromotion
            // (button should have been clicked by the automation)
            console.log('    üîç Starting screenshot process...');
            {
                try {
                    console.log('    ‚è≥ Waiting for page reload after button click...');

                    // Wait for navigation (page reload)
                    try {
                        await promoPage.waitForNavigation({
                            waitUntil: 'networkidle2',
                            timeout: 10000
                        });
                        console.log('    ‚úÖ Page reloaded');
                    } catch (navError) {
                        console.log('    ‚ö†Ô∏è  Navigation timeout (page might not reload), continuing...');
                    }

                    // Wait longer for result modal to appear
                    // The process: captcha modal -> button click -> page reload -> result modal
                    console.log('    ‚è≥ Waiting 10 seconds for result modal to appear...');
                    await promoPage.then(() => wait(10000); // Wait 10s for everything to complete

                    console.log('    ‚úÖ Wait completed, taking screenshot now');

                    console.log('    üì∏ Taking screenshot of result modal...');

                    // Create screenshots folder if not exists
                    const fs = require('fs');
                    const path = require('path');
                    const screenshotsDir = path.join(__dirname, '..', '..', 'screenshots');

                    if (!fs.existsSync(screenshotsDir)) {
                        fs.mkdirSync(screenshotsDir, { recursive: true });
                        console.log('    üìÅ Created screenshots directory');
                    }

                    // Generate filename with timestamp and site name
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const siteName = new URL(promoUrl).hostname.replace('www.', '').replace(/\./g, '-');
                    const filename = `promo-${siteName}-${username}-${timestamp}.png`;
                    const filepath = path.join(screenshotsDir, filename);

                    console.log('    üìÅ Screenshot path:', filepath);

                    // Take screenshot
                    await promoPage.screenshot({
                        path: filepath,
                        fullPage: false // Only visible area with modal
                    });

                    console.log('    ‚úÖ Screenshot saved:', filename);

                    // Verify file exists
                    if (fs.existsSync(filepath)) {
                        const stats = fs.statSync(filepath);
                        console.log(`    ‚úÖ File verified: ${stats.size} bytes`);

                        // Add screenshot path to result
                        result.screenshot = `/screenshots/${filename}`;
                        result.screenshotPath = filepath;

                        // Send result to dashboard API
                        try {
                            const axios = require('axios');
                            const siteNameClean = new URL(promoUrl).hostname.replace('www.', '');

                            await axios.post('http://localhost:3000/api/automation/result', {
                                profileName: 'Profile', // TODO: Get from config
                                username: username,
                                siteName: siteNameClean,
                                timestamp: Date.now(),
                                status: result.success ? 'success' : 'error',
                                screenshot: `/screenshots/${filename}`,
                                screenshotPath: filepath,
                                promotions: result.promotions || []
                            });

                            console.log('    ‚úÖ Result sent to dashboard');
                        } catch (error) {
                            console.error('    ‚ö†Ô∏è  Could not send result to dashboard:', error.message);
                        }
                    } else {
                        console.error('    ‚ùå Screenshot file not found after save!');
                    }

                } catch (screenshotError) {
                    console.error('    ‚ùå Screenshot error:', screenshotError.message);
                    console.error('    üìä Error stack:', screenshotError.stack);
                }
            }

            console.log('    ‚ÑπÔ∏è  Keeping promo page open for inspection...');
            return result;

        } catch (error) {
            console.error('    ‚ùå Error:', error.message);
            console.error('    üìä Error stack:', error.stack);
            return { success: false, promotions: [], message: error.message };
        }
    }
}

module.exports = CompleteAutomation;
