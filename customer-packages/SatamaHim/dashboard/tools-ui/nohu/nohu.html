<!-- Load Common CSS -->
<link rel="stylesheet" href="tools-ui/common.css">
<!-- Load NOHU Tool Specific CSS -->
<link rel="stylesheet" href="tools-ui/nohu/nohu.css">
<!-- Load Shared JS (drag-to-scroll, etc.) -->
<script src="tools-ui/shared/shared.js"></script>

<!-- Inline Critical CSS for immediate rendering -->
<style>
    .nohu-tool-container {
        padding: 0;
        width: 100%;
    }

    .form-section {
        background: #f7fafc;
        padding: 20px;
        border-radius: 12px;
        margin-bottom: 20px;
        border: 1px solid #e2e8f0;
    }

    .results-table-wrapper {
        overflow-x: auto;
        overflow-y: auto;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        flex: 1 1 auto;
        min-height: 200px;
        /* Minimum height */
        max-height: calc(100vh - 400px);
        /* Responsive max height */
        border: 1px solid #e5e7eb;
    }

    .results-table {
        width: 100%;
        border-collapse: collapse;
        background: white;
        border-radius: 12px;
        overflow: hidden;
    }

    .results-table thead {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
    }

    .results-table th {
        padding: 15px;
        text-align: left;
        font-weight: 600;
        font-size: 14px;
    }

    .results-table td {
        padding: 15px;
        border-bottom: 1px solid #e2e8f0;
        font-size: 14px;
        color: #2d3748;
    }

    /* Check times badge */
    .check-times-badge {
        display: inline-block;
        padding: 4px 12px;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border-radius: 12px;
        font-size: 13px;
        font-weight: 600;
    }

    /* Warning button */
    .btn-warning {
        background: linear-gradient(135deg, #f59e0b, #d97706);
        color: white;
        border: none;
        padding: 8px 16px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.3s ease;
    }

    .btn-warning:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
    }

    /* Warning Banner Important */
    .warning-banner-important {
        background: linear-gradient(135deg, #fef3c7, #fde68a);
        border: 2px solid #f59e0b;
        border-radius: 12px;
        padding: 16px;
        margin-bottom: 20px;
        display: flex;
        align-items: center;
        gap: 12px;
        box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);
        animation: pulseWarning 2s ease-in-out infinite;
    }

    .warning-icon {
        font-size: 24px;
        flex-shrink: 0;
    }

    .warning-content {
        color: #92400e;
        font-size: 14px;
        line-height: 1.5;
        font-weight: 500;
    }

    .warning-content strong {
        color: #78350f;
        font-weight: 700;
    }

    @keyframes pulseWarning {

        0%,
        100% {
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.2);
        }

        50% {
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.4);
        }
    }

    /* Screenshot grid hover effects */
    .screenshot-item:hover {
        transform: translateY(-2px) !important;
        box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15) !important;
    }

    .screenshot-item:hover img {
        transform: scale(1.02) !important;
    }

    /* Hide scrollbar but keep scroll functionality */
    .hide-scrollbar {
        -ms-overflow-style: none;
        /* Internet Explorer 10+ */
        scrollbar-width: none;
        /* Firefox */
    }

    .hide-scrollbar::-webkit-scrollbar {
        display: none;
        /* Safari and Chrome */
    }

    /* Apply to ALL scroll areas - hide scrollbar everywhere */
    .modal-body,
    .results-table-wrapper,
    .screenshots-grid,
    .profile-carousel,
    .modal-sites-column,
    .modal-form-column,
    .modal-tabs-left,
    .tab-content {
        -ms-overflow-style: none;
        scrollbar-width: none;
    }

    .modal-body::-webkit-scrollbar,
    .results-table-wrapper::-webkit-scrollbar,
    .screenshots-grid::-webkit-scrollbar,
    .profile-carousel::-webkit-scrollbar,
    .modal-sites-column::-webkit-scrollbar,
    .modal-form-column::-webkit-scrollbar,
    .modal-tabs-left::-webkit-scrollbar,
    .tab-content::-webkit-scrollbar {
        display: none;
    }

    /* Force grid layout - 3 columns with larger images */
    .screenshots-grid {
        display: grid !important;
        grid-template-columns: repeat(3, 1fr) !important;
        gap: 20px !important;
        padding: 20px !important;
        width: 100% !important;
        box-sizing: border-box !important;
    }

    .screenshot-item {
        width: auto !important;
        max-width: 100% !important;
        min-width: 0 !important;
        display: block !important;
    }

    /* Responsive grid adjustments */
    @media (max-width: 768px) {
        .screenshots-grid {
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)) !important;
            gap: 10px !important;
            padding: 15px !important;
        }
    }

    @media (min-width: 1200px) {
        .screenshots-grid {
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)) !important;
        }
    }
</style>

<!-- NOHU Auto Tool UI -->
<div class="nohu-tool-container">

    <!-- Info Banner -->
    <div class="info-banner">
        <h3>üé∞ NOHU Auto Tool</h3>
        <p>T·ª± ƒë·ªông ƒëƒÉng k√Ω, ƒëƒÉng nh·∫≠p, th√™m ng√¢n h√†ng v√† check khuy·∫øn m√£i cho c√°c trang game</p>
    </div>



    <!-- Results Full Width -->
    <div class="results-full-width">
        <!-- Header with START button -->
        <div class="results-header">
            <h2>üìä K·∫øt Qu·∫£ Automation</h2>
            <div class="header-actions">
                <button class="btn btn-secondary btn-sm" onclick="refreshResults()">
                    üîÑ T·∫£i L·∫°i
                </button>
                <button class="btn btn-warning btn-sm" onclick="deleteSelectedResults()">
                    üóëÔ∏è X√≥a ƒê√£ Ch·ªçn
                </button>
                <button class="btn btn-danger btn-sm" onclick="deleteAllResults()"
                    style="background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border: none;">
                    üóëÔ∏è X√≥a T·∫•t C·∫£
                </button>
                <button class="btn btn-start" onclick="openFormModal()">
                    <span class="start-icon">‚ñ∂Ô∏è</span>
                    <span class="start-text">START</span>
                </button>

            </div>
        </div>

        <div class="results-section" id="resultsSection">
            <div class="results-table-wrapper">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th style="width: 40px;">
                                <input type="checkbox" id="selectAllCheckbox" onchange="toggleSelectAll(this)"
                                    style="cursor: pointer; width: 18px; height: 18px;">
                            </th>
                            <th>Profile</th>
                            <th>T√†i Kho·∫£n</th>
                            <th>L·∫ßn Check</th>
                            <th>Tr·∫°ng Th√°i</th>
                            <th>K·∫øt Qu·∫£</th>
                            <th>Th·ªùi Gian</th>
                            <th>Tra Khuy·∫øn M√£i</th>
                        </tr>
                    </thead>
                    <tbody id="resultsTableBody">
                        <tr>
                            <td colspan="8" style="text-align: center; color: #a0aec0; padding: 40px;">
                                Ch∆∞a c√≥ k·∫øt qu·∫£. Ch·∫°y automation ƒë·ªÉ xem k·∫øt qu·∫£ ·ªü ƒë√¢y.
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <!-- Pagination Controls -->
            <div class="pagination-controls" id="paginationControls">
                <div class="pagination-info">
                    Hi·ªÉn th·ªã <span id="pageStart">0</span>-<span id="pageEnd">0</span> / <span
                        id="totalResults">0</span>
                    k·∫øt qu·∫£
                </div>
                <div class="pagination-buttons">
                    <button class="btn btn-sm" onclick="goToFirstPage()" id="btnFirst">‚èÆÔ∏è ƒê·∫ßu</button>
                    <button class="btn btn-sm" onclick="goToPrevPage()" id="btnPrev">‚óÄÔ∏è Tr∆∞·ªõc</button>
                    <span class="page-indicator">
                        Trang <span id="currentPage">1</span> / <span id="totalPages">1</span>
                    </span>
                    <button class="btn btn-sm" onclick="goToNextPage()" id="btnNext">Sau ‚ñ∂Ô∏è</button>
                    <button class="btn btn-sm" onclick="goToLastPage()" id="btnLast">Cu·ªëi ‚è≠Ô∏è</button>
                </div>
                <div class="pagination-size">
                    <span style="color: #6b7280; font-size: 13px;">
                        üìè 4 k·∫øt qu·∫£ m·ªói trang
                    </span>
                </div>
            </div>
        </div>

        <!-- Screenshots Modal -->
        <div id="screenshotsModal" class="screenshots-modal" style="display: none;">
            <div class="modal-overlay" onclick="closeScreenshotsModal()"></div>
            <div class="modal-content-fullscreen">
                <div class="modal-header">
                    <h3 id="modalTitle">üì∑ K·∫øt Qu·∫£</h3>
                    <button class="modal-close" onclick="closeScreenshotsModal()">√ó</button>
                </div>
                <div class="modal-body" id="modalScreenshotsGrid">
                    <!-- Screenshots will be loaded here -->
                </div>
            </div>
        </div>

        <!-- Account Info Modal -->
        <div id="accountInfoModal" class="screenshots-modal" style="display: none;">
            <div class="modal-overlay" onclick="closeAccountInfoModal()"></div>
            <div class="modal-content-large">
                <div class="modal-header">
                    <h3 id="accountInfoTitle">üìã Th√¥ng Tin T√†i Kho·∫£n</h3>
                    <button class="modal-close" onclick="closeAccountInfoModal()">√ó</button>
                </div>
                <div class="modal-body" id="accountInfoContent" style="padding: 20px;">
                    <!-- Account info will be loaded here -->
                </div>
            </div>
        </div>

        <!-- Select Sites Modal for Check Promo -->
        <div id="selectSitesModal" class="screenshots-modal" style="display: none;">
            <div class="modal-overlay" onclick="closeSelectSitesModal()"></div>
            <div class="modal-content-large" style="max-width: 600px;">
                <div class="modal-header">
                    <h3>üéØ Ch·ªçn Trang C·∫ßn Check</h3>
                    <button class="modal-close" onclick="closeSelectSitesModal()">√ó</button>
                </div>
                <div class="modal-body" style="padding: 20px;">
                    <div style="margin-bottom: 20px;">
                        <p style="color: #6b7280; margin-bottom: 15px;">
                            Ch·ªçn c√°c trang b·∫°n mu·ªën check khuy·∫øn m√£i:
                        </p>
                        <div id="sitesCheckboxList" style="display: flex; flex-direction: column; gap: 12px;">
                            <!-- Site checkboxes will be loaded here -->
                        </div>
                    </div>
                    <div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">
                        <button class="btn btn-secondary" onclick="closeSelectSitesModal()">
                            H·ªßy
                        </button>
                        <button class="btn btn-primary" onclick="confirmCheckPromo()"
                            style="background: linear-gradient(135deg, #10b981, #059669);">
                            ‚ñ∂Ô∏è Ch·∫°y Check
                        </button>
                    </div>
                </div>
            </div>
        </div>


    </div>
    <!-- End Results Section -->

    <!-- Form Modal -->
    <div class="form-modal" id="formModal">
        <div class="modal-content-form">
            <!-- Modal Header -->
            <div class="modal-header-form">
                <h2>üé∞ NOHU Auto Tool</h2>
                <button class="modal-close-form" onclick="closeFormModal()">√ó</button>
            </div>

            <!-- Tabs in Modal -->
            <div class="modal-tabs">
                <div class="modal-tabs-left">
                    <div class="modal-tab active" data-tab="auto" onclick="switchModalTab('auto')">
                        ü§ñ T·ª± ƒê·ªông
                    </div>
                    <!-- Hidden: Individual functions (Register, Login) -->
                    <div class="modal-tab" data-tab="register" onclick="switchModalTab('register')"
                        style="display: none;">
                        üìù ƒêƒÉng K√Ω
                    </div>
                    <div class="modal-tab" data-tab="login" onclick="switchModalTab('login')" style="display: none;">
                        üîê ƒêƒÉng Nh·∫≠p
                    </div>
                    <!-- Hidden: Individual functions (Add Bank) -->
                    <div class="modal-tab" data-tab="bank" onclick="switchModalTab('bank')" style="display: none;">
                        üí≥ Th√™m Bank
                    </div>
                    <div class="modal-tab" data-tab="promo" onclick="switchModalTab('promo')">
                        üéÅ Check KM
                    </div>
                </div>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <button class="btn btn-warning btn-sm" onclick="clearAllRunningStatuses()"
                        title="Clear t·∫•t c·∫£ tr·∫°ng th√°i running" style="padding: 8px 12px; font-size: 12px;">
                        üîÑ Clear Running
                    </button>
                    <button class="btn-run-action" id="btnRunAction" onclick="runCurrentTabAction()">
                        üöÄ CH·∫†Y
                    </button>
                </div>
            </div>

            <!-- Modal Body - 2 Column Layout -->
            <div class="modal-body-form" id="modalBodyForm">
                <!-- Warning Banner in Form - Redesigned -->
                <div
                    style="grid-column: 1 / -1; margin-bottom: 15px; background: linear-gradient(135deg, #fef3c7, #fde68a); border-radius: 12px; padding: 16px; border: 1px solid #f59e0b; box-shadow: 0 2px 8px rgba(245, 158, 11, 0.15);">
                    <div style="display: flex; align-items: flex-start; gap: 12px;">
                        <div style="font-size: 24px; line-height: 1;">üí°</div>
                        <div style="flex: 1;">
                            <div style="font-weight: 700; color: #92400e; font-size: 14px; margin-bottom: 8px;">Khuy·∫øn
                                ngh·ªã s·ª≠ d·ª•ng</div>
                            <div
                                style="display: flex; flex-direction: column; gap: 6px; font-size: 12px; color: #78350f;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="color: #f59e0b;">‚óè</span>
                                    <span>N√™n <strong>m·ªü profile c·∫ßn ch·∫°y</strong> trong Hidemium tr∆∞·ªõc khi s·ª≠ d·ª•ng
                                        tool</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="color: #f59e0b;">‚óè</span>
                                    <span><strong>Song Song (3-5 sites)</strong>: Nhanh h∆°n, ph√π h·ª£p m√°y m·∫°nh</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <span style="color: #f59e0b;">‚óè</span>
                                    <span><strong>Tu·∫ßn T·ª±</strong>: ·ªîn ƒë·ªãnh h∆°n, ph√π h·ª£p m√°y y·∫øu ho·∫∑c m·∫°ng ch·∫≠m</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- LEFT COLUMN: Sites Selection -->
                <div class="modal-sites-column">
                    <!-- Promo Type Selection (Only show in Auto tab) -->
                    <div id="promoTypeSelector"
                        style="margin-bottom: 12px; padding: 8px; background: white; border-radius: 8px; border: 1px solid #e5e7eb;">
                        <h4 style="margin: 0 0 6px 0; color: #4a5568; font-size: 12px; font-weight: 600;">üéØ Lo·∫°i KM
                        </h4>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                            <label class="promo-type-card"
                                style="display: flex; align-items: center; justify-content: center; gap: 4px; cursor: pointer; padding: 8px; background: #f9fafb; border-radius: 6px; border: 2px solid #e5e7eb; transition: all 0.2s; text-align: center;">
                                <input type="radio" name="promoType" value="app" checked onchange="togglePromoSites()"
                                    style="display: none;">
                                <span style="font-size: 16px;">üì±</span>
                                <span style="font-size: 11px; font-weight: 600;">T·∫£i App</span>
                            </label>
                            <label class="promo-type-card"
                                style="display: flex; align-items: center; justify-content: center; gap: 4px; cursor: pointer; padding: 8px; background: #f9fafb; border-radius: 6px; border: 2px solid #e5e7eb; transition: all 0.2s; text-align: center;">
                                <input type="radio" name="promoType" value="sms" onchange="togglePromoSites()"
                                    style="display: none;">
                                <span style="font-size: 16px;">üí¨</span>
                                <span style="font-size: 11px; font-weight: 600;">SMS</span>
                            </label>
                        </div>
                    </div>

                    <!-- Group 1: Khuy·∫øn M√£i T·∫£i App -->
                    <div id="appPromoGroup" style="margin-bottom: 12px;">
                        <h4 style="margin: 0 0 8px 0; color: #4a5568; font-size: 13px; font-weight: 600;">
                            üì± Khuy·∫øn M√£i T·∫£i App
                        </h4>
                        <div class="sites-grid" id="appPromoSites">
                            <!-- Sites will be rendered dynamically -->
                        </div>
                        <div class="site-actions">
                            <button class="btn btn-sm" onclick="selectAppPromoSites()">‚úÖ Ch·ªçn T·∫•t C·∫£</button>
                            <button class="btn btn-sm" onclick="deselectAppPromoSites()">‚ùå B·ªè Ch·ªçn</button>
                        </div>
                    </div>

                    <!-- Execution Mode Settings (moved to left column) -->
                    <div id="executionModeSection"
                        style="margin-bottom: 12px; padding: 10px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                        <h4 style="margin: 0 0 10px 0; color: #4a5568; font-size: 13px; font-weight: 600;">‚öôÔ∏è Ch·∫ø ƒê·ªô
                            Ch·∫°y</h4>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <label
                                style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 8px 12px; background: white; border-radius: 6px; border: 1px solid #e2e8f0; flex: 1;">
                                <input type="radio" name="executionMode" value="parallel" checked
                                    style="width: 16px; height: 16px;">
                                <div>
                                    <div style="font-weight: 600; font-size: 12px; color: #2d3748;">üöÄ Song Song</div>
                                    <div style="font-size: 10px; color: #718096;">Nhanh h∆°n</div>
                                </div>
                            </label>
                            <label
                                style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 8px 12px; background: white; border-radius: 6px; border: 1px solid #e2e8f0; flex: 1;">
                                <input type="radio" name="executionMode" value="sequential"
                                    style="width: 16px; height: 16px;">
                                <div>
                                    <div style="font-weight: 600; font-size: 12px; color: #2d3748;">üìã Tu·∫ßn T·ª±</div>
                                    <div style="font-size: 10px; color: #718096;">·ªîn ƒë·ªãnh h∆°n</div>
                                </div>
                            </label>
                        </div>
                        <div id="parallelOptions" style="margin-top: 8px;">
                            <label
                                style="display: flex; align-items: center; gap: 6px; font-size: 12px; color: #4a5568;">
                                <span>S·ªë sites c√πng l√∫c:</span>
                                <select id="parallelCount"
                                    style="padding: 4px 8px; border-radius: 4px; border: 1px solid #e2e8f0; font-size: 12px;">
                                    <option value="0">T·∫•t c·∫£</option>
                                    <option value="3" selected>3</option>
                                    <option value="5">5</option>
                                    <option value="7">7</option>
                                </select>
                            </label>
                        </div>
                    </div>

                    <!-- Captcha Delay Options -->
                    <div
                        style="padding: 10px; background: #f0f9ff; border-radius: 8px; border: 1px solid #bfdbfe; margin-bottom: 12px;">
                        <h4 style="margin: 0 0 10px 0; color: #1e40af; font-size: 13px; font-weight: 600;">‚è±Ô∏è Delay
                            Captcha</h4>
                        <label style="display: flex; align-items: center; gap: 8px; font-size: 12px; color: #1e40af;">
                            <span>Ch·ªù tr∆∞·ªõc khi submit:</span>
                            <select id="autoCaptchaDelay"
                                style="padding: 6px 10px; border-radius: 6px; border: 1px solid #bfdbfe; font-size: 12px; background: white;">
                                <option value="0" selected>Kh√¥ng delay (0s)</option>
                                <option value="5">5 gi√¢y</option>
                                <option value="10">10 gi√¢y</option>
                                <option value="15">15 gi√¢y</option>
                                <option value="20">20 gi√¢y</option>
                                <option value="30">30 gi√¢y</option>
                            </select>
                        </label>
                        <div style="font-size: 11px; color: #1e40af; margin-top: 6px; font-style: italic;">
                            üí° Tr√°nh detect bot, ƒë·ªÉ tool t·ª± ƒë·ªông ch·∫°y
                        </div>
                    </div>

                    <!-- CheckPromo Option -->
                    <div
                        style="padding: 10px; background: #f0fdf4; border-radius: 8px; border: 1px solid #bbf7d0; margin-bottom: 12px;">
                        <label
                            style="display: flex; align-items: center; gap: 8px; font-size: 12px; color: #15803d; cursor: pointer;">
                            <input type="checkbox" id="enableCheckPromo" checked
                                style="width: 16px; height: 16px; cursor: pointer;">
                            <span style="font-weight: 600;">üéÅ Ch·∫°y Check Khuy·∫øn M√£i sau khi Th√™m Bank</span>
                        </label>
                        <div
                            style="font-size: 11px; color: #15803d; margin-top: 6px; margin-left: 24px; font-style: italic;">
                            ‚úì B·∫≠t: T·ª± ƒë·ªông check khuy·∫øn m√£i sau khi th√™m bank th√†nh c√¥ng
                            <br>‚úó T·∫Øt: Ch·ªâ ƒëƒÉng k√Ω + th√™m bank, kh√¥ng check khuy·∫øn m√£i
                        </div>
                    </div>

                    <!-- Group 2: Khuy·∫øn M√£i Tin Nh·∫Øn SMS -->
                    <div id="smsPromoGroup" style="margin-bottom: 12px; display: none;">
                        <h4 style="margin: 0 0 8px 0; color: #4a5568; font-size: 13px; font-weight: 600;">
                            üí¨ Khuy·∫øn M√£i Tin Nh·∫Øn SMS
                        </h4>
                        <div class="sites-grid" id="smsPromoSites">
                            <!-- Sites will be rendered dynamically -->
                        </div>
                        <div class="site-actions">
                            <button class="btn btn-sm" onclick="selectSmsPromoSites()">‚úÖ Ch·ªçn T·∫•t C·∫£</button>
                            <button class="btn btn-sm" onclick="deselectSmsPromoSites()">‚ùå B·ªè Ch·ªçn</button>
                        </div>
                    </div>
                </div>
                <!-- End LEFT COLUMN -->

                <!-- RIGHT COLUMN: Form Inputs -->
                <div class="modal-form-column">
                    <!-- Tab Content: Auto -->
                    <div class="tab-content active" id="tab-auto">
                        <div class="form-section" style="padding: 12px; margin-bottom: 12px;">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h3 style="margin: 0; font-size: 13px;">üìã Ch·ªçn Profile</h3>
                                <button class="btn btn-secondary btn-sm" onclick="loadProfilesCarousel(true)"
                                    title="T·∫£i l·∫°i profiles" style="padding: 4px 8px; font-size: 11px;">üîÑ
                                    T·∫£i L·∫°i</button>
                            </div>

                            <!-- Profile Carousel -->
                            <div class="profile-carousel-wrapper">
                                <div class="profile-carousel-container">
                                    <button class="carousel-btn carousel-prev"
                                        onclick="scrollProfileCarousel('auto', -1)">‚Äπ</button>
                                    <div class="profile-carousel" id="autoProfileCarousel">
                                        <div class="profile-carousel-empty">
                                            <p style="font-size: 12px;">Click "T·∫£i L·∫°i" ƒë·ªÉ xem profiles</p>
                                        </div>
                                    </div>
                                    <button class="carousel-btn carousel-next"
                                        onclick="scrollProfileCarousel('auto', 1)">‚Ä∫</button>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h3 style="margin: 0;">üë§ Th√¥ng Tin T√†i Kho·∫£n</h3>
                                <button class="btn btn-secondary btn-sm" onclick="randomAllForm()"
                                    title="Random to√†n b·ªô form">
                                    üé≤ Random
                                </button>
                            </div>
                            <div class="form-grid">
                                <input type="text" id="autoUsername" placeholder="T√™n t√†i kho·∫£n">
                                <input type="text" id="autoFullname" placeholder="H·ªç v√† T√™n (IN HOA)">
                                <input type="text" id="autoPassword" placeholder="M·∫≠t kh·∫©u">
                                <input type="text" id="autoWithdrawPassword" placeholder="MK r√∫t ti·ªÅn">
                            </div>
                        </div>

                        <div class="form-section">
                            <h3>üí≥ Th√¥ng Tin Ng√¢n H√†ng</h3>
                            <div class="form-grid">
                                <select id="autoBankName">
                                    <option value="">Ch·ªçn ng√¢n h√†ng...</option>
                                </select>
                                <input type="text" id="autoBankBranch" placeholder="Chi nh√°nh">
                                <input type="text" id="autoAccountNumber" placeholder="S·ªë t√†i kho·∫£n">
                            </div>
                        </div>

                    </div>

                    <!-- Tab Content: Register -->
                    <div class="tab-content" id="tab-register">
                        <div class="form-section" style="padding: 12px; margin-bottom: 12px;">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h3 style="margin: 0; font-size: 13px;">üìã Ch·ªçn Profile</h3>
                                <button class="btn btn-secondary btn-sm" onclick="loadProfilesCarousel(true)"
                                    title="T·∫£i l·∫°i profiles" style="padding: 4px 8px; font-size: 11px;">üîÑ
                                    T·∫£i L·∫°i</button>
                            </div>

                            <!-- Profile Carousel -->
                            <div class="profile-carousel-wrapper">
                                <div class="profile-carousel-container">
                                    <button class="carousel-btn carousel-prev"
                                        onclick="scrollProfileCarousel('reg', -1)">‚Äπ</button>
                                    <div class="profile-carousel" id="regProfileCarousel">
                                        <div class="profile-carousel-empty">
                                            <p style="font-size: 12px;">Click "T·∫£i L·∫°i" ƒë·ªÉ xem profiles</p>
                                        </div>
                                    </div>
                                    <button class="carousel-btn carousel-next"
                                        onclick="scrollProfileCarousel('reg', 1)">‚Ä∫</button>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h3>üë§ Th√¥ng Tin ƒêƒÉng K√Ω</h3>
                            <div class="form-grid">
                                <input type="text" id="regUsername" placeholder="T√™n t√†i kho·∫£n">
                                <input type="text" id="regFullname" placeholder="H·ªç v√† T√™n (IN HOA)">
                                <input type="text" id="regPassword" placeholder="M·∫≠t kh·∫©u">
                                <input type="text" id="regWithdrawPassword" placeholder="MK r√∫t ti·ªÅn">
                            </div>
                        </div>
                    </div>

                    <!-- Tab Content: Login -->
                    <div class="tab-content" id="tab-login">
                        <div class="form-section" style="padding: 12px; margin-bottom: 12px;">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h3 style="margin: 0; font-size: 13px;">üìã Ch·ªçn Profile</h3>
                                <button class="btn btn-secondary btn-sm" onclick="loadProfilesCarousel(true)"
                                    title="T·∫£i l·∫°i profiles" style="padding: 4px 8px; font-size: 11px;">üîÑ
                                    T·∫£i L·∫°i</button>
                            </div>

                            <!-- Profile Carousel -->
                            <div class="profile-carousel-wrapper">
                                <div class="profile-carousel-container">
                                    <button class="carousel-btn carousel-prev"
                                        onclick="scrollProfileCarousel('login', -1)">‚Äπ</button>
                                    <div class="profile-carousel" id="loginProfileCarousel">
                                        <div class="profile-carousel-empty">
                                            <p style="font-size: 12px;">Click "T·∫£i L·∫°i" ƒë·ªÉ xem profiles</p>
                                        </div>
                                    </div>
                                    <button class="carousel-btn carousel-next"
                                        onclick="scrollProfileCarousel('login', 1)">‚Ä∫</button>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h3>üîê Th√¥ng Tin ƒêƒÉng Nh·∫≠p</h3>
                            <div class="form-grid">
                                <input type="text" id="loginUsername" placeholder="T√™n t√†i kho·∫£n">
                                <input type="text" id="loginPassword" placeholder="M·∫≠t kh·∫©u">
                            </div>
                        </div>
                    </div>

                    <!-- Tab Content: Bank -->
                    <div class="tab-content" id="tab-bank">
                        <div class="warning-banner">
                            <strong>‚ö†Ô∏è L∆∞u √Ω:</strong> B·∫°n c·∫ßn ƒëƒÉng nh·∫≠p tr∆∞·ªõc v√†o c√°c trang tr∆∞·ªõc khi s·ª≠ d·ª•ng ch·ª©c nƒÉng
                            n√†y.
                        </div>

                        <div class="form-section" style="padding: 12px; margin-bottom: 12px;">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h3 style="margin: 0; font-size: 13px;">üìã Ch·ªçn Profile</h3>
                                <button class="btn btn-secondary btn-sm" onclick="loadProfilesCarousel(true)"
                                    title="T·∫£i l·∫°i profiles" style="padding: 4px 8px; font-size: 11px;">üîÑ
                                    T·∫£i L·∫°i</button>
                            </div>

                            <!-- Profile Carousel -->
                            <div class="profile-carousel-wrapper">
                                <div class="profile-carousel-container">
                                    <button class="carousel-btn carousel-prev"
                                        onclick="scrollProfileCarousel('bank', -1)">‚Äπ</button>
                                    <div class="profile-carousel" id="bankProfileCarousel">
                                        <div class="profile-carousel-empty">
                                            <p style="font-size: 12px;">Click "T·∫£i L·∫°i" ƒë·ªÉ xem profiles</p>
                                        </div>
                                    </div>
                                    <button class="carousel-btn carousel-next"
                                        onclick="scrollProfileCarousel('bank', 1)">‚Ä∫</button>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h3 style="font-size: 13px;">üí≥ Th√¥ng Tin Ng√¢n H√†ng</h3>
                            <div class="form-grid">
                                <select id="bankBankName">
                                    <option value="">Ch·ªçn ng√¢n h√†ng...</option>
                                </select>
                                <input type="text" id="bankBankBranch" placeholder="Chi nh√°nh">
                                <input type="text" id="bankAccountNumber" placeholder="S·ªë t√†i kho·∫£n">
                            </div>
                        </div>
                    </div>

                    <!-- Tab Content: Promo -->
                    <div class="tab-content" id="tab-promo">
                        <div class="form-section" style="padding: 12px; margin-bottom: 12px;">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                <h3 style="margin: 0; font-size: 13px;">üìã Ch·ªçn Profile</h3>
                                <button class="btn btn-secondary btn-sm" onclick="loadProfilesCarousel(true)"
                                    title="T·∫£i l·∫°i profiles" style="padding: 4px 8px; font-size: 11px;">üîÑ
                                    T·∫£i L·∫°i</button>
                            </div>

                            <!-- Profile Carousel -->
                            <div class="profile-carousel-wrapper">
                                <div class="profile-carousel-container">
                                    <button class="carousel-btn carousel-prev"
                                        onclick="scrollProfileCarousel('promo', -1)">‚Äπ</button>
                                    <div class="profile-carousel" id="promoProfileCarousel">
                                        <div class="profile-carousel-empty">
                                            <p style="font-size: 12px;">Click "T·∫£i L·∫°i" ƒë·ªÉ xem profiles</p>
                                        </div>
                                    </div>
                                    <button class="carousel-btn carousel-next"
                                        onclick="scrollProfileCarousel('promo', 1)">‚Ä∫</button>
                                </div>
                            </div>
                        </div>

                        <div class="form-section">
                            <h3 style="font-size: 13px;">üë§ Th√¥ng Tin T√†i Kho·∫£n</h3>
                            <input type="text" id="promoUsername" placeholder="T√™n t√†i kho·∫£n" class="full-width">
                        </div>

                    </div>

                    <!-- Tab Content: Profile Management -->
                    <div class="tab-content" id="tab-profiles">
                        <div class="info-banner">
                            <h3>üìã Qu·∫£n L√Ω Profiles</h3>
                            <p>T·∫°o, x√≥a, start/stop profiles. Ch·ªçn profile ƒë·ªÉ ch·∫°y automation.</p>
                        </div>

                        <!-- Profile Actions -->
                        <div class="form-section">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                <h3 style="margin: 0;">üìã Danh S√°ch Profiles</h3>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn btn-primary" onclick="openCreateProfileModal()">
                                        ‚ûï T·∫°o Profile
                                    </button>
                                    <button class="btn btn-secondary" onclick="loadProfilesForTool()">
                                        üîÑ T·∫£i L·∫°i
                                    </button>
                                </div>
                            </div>

                            <!-- Bulk Actions -->
                            <div id="toolBulkActions"
                                style="background: #f7fafc; padding: 15px; border-radius: 8px; margin-bottom: 15px; display: none;">
                                <div style="display: flex; gap: 10px; flex-wrap: wrap; align-items: center;">
                                    <button class="btn btn-primary" onclick="startSelectedProfiles()">
                                        ‚ñ∂Ô∏è Start ƒë√£ ch·ªçn
                                    </button>
                                    <button class="btn btn-secondary" onclick="stopSelectedProfiles()">
                                        ‚èπÔ∏è Stop ƒë√£ ch·ªçn
                                    </button>
                                    <button class="btn btn-danger" onclick="deleteSelectedProfiles()">
                                        üóëÔ∏è X√≥a ƒë√£ ch·ªçn
                                    </button>
                                    <button class="btn btn-sm" onclick="selectAllProfiles()">‚úÖ Ch·ªçn t·∫•t c·∫£</button>
                                    <button class="btn btn-sm" onclick="deselectAllProfiles()">‚ùå B·ªè ch·ªçn</button>
                                    <div style="flex: 1; text-align: right;">
                                        <span id="toolSelectedCount" style="color: #4a5568; font-weight: 600;">
                                            ƒê√£ ch·ªçn: 0 profile(s)
                                        </span>
                                    </div>
                                </div>
                            </div>

                            <!-- Profiles Grid -->
                            <div id="toolProfilesGrid" class="profiles-grid-tool">
                                <p class="empty-state">Click "T·∫£i L·∫°i" ƒë·ªÉ xem profiles</p>
                            </div>
                        </div>

                        <!-- Selected Profile Info -->
                        <div class="form-section" id="selectedProfileInfo" style="display: none;">
                            <h3>‚úÖ Profile ƒê√£ Ch·ªçn</h3>
                            <div
                                style="background: linear-gradient(135deg, #ebf4ff, #e0e7ff); padding: 15px; border-radius: 8px; border-left: 4px solid #667eea;">
                                <div style="font-weight: 600; font-size: 16px; color: #2d3748; margin-bottom: 8px;"
                                    id="selectedProfileName">
                                    Profile Name
                                </div>
                                <div style="font-size: 14px; color: #718096;" id="selectedProfileDetails">
                                    OS | Browser | Proxy
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- End RIGHT COLUMN -->
            </div>
            <!-- End modal-body-form -->

        </div>
    </div>
</div>

</div>
<!-- End nohu-tool-container -->

<!-- NOHU Tool JavaScript -->
<script>
    // Helper function to disable button until server responds
    function disableButton(button) {
        if (!button) return;

        button.disabled = true;
        button.style.opacity = '0.5';
        button.style.cursor = 'not-allowed';
        button.style.pointerEvents = 'none';
    }

    // Helper function to enable button after server responds
    function enableButton(button) {
        if (!button) return;

        button.disabled = false;
        button.style.opacity = '1';
        button.style.cursor = 'pointer';
        button.style.pointerEvents = 'auto';
    }

    // Helper function to disable button for 0.5s to prevent double-click (deprecated, use disableButton/enableButton instead)
    function disableButtonTemporarily(button, duration = 500) {
        if (!button) return;

        const originalOpacity = button.style.opacity;
        const originalCursor = button.style.cursor;
        const originalPointerEvents = button.style.pointerEvents;

        button.disabled = true;
        button.style.opacity = '0.5';
        button.style.cursor = 'not-allowed';
        button.style.pointerEvents = 'none';

        setTimeout(() => {
            button.disabled = false;
            button.style.opacity = originalOpacity || '1';
            button.style.cursor = originalCursor || 'pointer';
            button.style.pointerEvents = originalPointerEvents || 'auto';
        }, duration);
    }

    // Initialize tool when loaded
    window.initToolUI = function (tool) {
        console.log('üé∞ Initializing NOHU Tool UI...', tool);

        // Clear any existing results data from previous tool
        Object.keys(resultsData).forEach(key => delete resultsData[key]);
        processedResults.clear();

        // Show loading state immediately to prevent showing previous tool's data
        const tbody = document.getElementById('resultsTableBody');
        if (tbody) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="8" style="text-align: center; color: #6366f1; padding: 40px;">
                        <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                            <div style="width: 20px; height: 20px; border: 2px solid #6366f1; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite;"></div>
                            ƒêang t·∫£i k·∫øt qu·∫£ NOHU Tool...
                        </div>
                    </td>
                </tr>
            `;
        }

        // Initialize tab switching
        initTabSwitching();

        // Initialize promo type switching
        initPromoTypeSwitching();

        // Initialize execution mode toggle
        initExecutionModeToggle();

        // Load banks
        loadBanksForTool();

        // Load profiles for carousel
        loadProfilesCarousel();

        // Load results from server (scan actual screenshot files)
        // This ensures we always show accurate results based on actual files
        loadResultsFromServer();

        console.log('‚úÖ NOHU Tool initialized');
    };

    // Validate API key format (client-side validation)
    function validateApiKeyFormat(apiKey) {
        if (!apiKey || typeof apiKey !== 'string') {
            return { valid: false, error: 'API key ph·∫£i l√† chu·ªói k√Ω t·ª±' };
        }

        const trimmed = apiKey.trim();

        if (trimmed.length === 0) {
            return { valid: false, error: 'API key kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng' };
        }

        if (trimmed.length < 10) {
            return { valid: false, error: 'API key qu√° ng·∫Øn (t·ªëi thi·ªÉu 10 k√Ω t·ª±)' };
        }

        // Check for valid characters (alphanumeric and common special chars)
        if (!/^[a-zA-Z0-9\-_]+$/.test(trimmed)) {
            return { valid: false, error: 'API key ch·ª©a k√Ω t·ª± kh√¥ng h·ª£p l·ªá (ch·ªâ ch·∫•p nh·∫≠n a-z, A-Z, 0-9, -, _)' };
        }

        return { valid: true, key: trimmed };
    }

    // Wait for server to actually start automation (check if it's in running status)
    async function waitForServerStart(username, maxWaitTime = 30000) {
        const startTime = Date.now();
        const checkInterval = 500; // Check every 500ms

        console.log(`‚è≥ Waiting for server to start automation for ${username}...`);

        while (Date.now() - startTime < maxWaitTime) {
            try {
                const response = await fetch('/api/automation/statuses');
                const data = await response.json();

                if (data.success && data.statuses) {
                    // Check if this username is in running status
                    const isRunning = data.statuses.some(status =>
                        status.username === username && status.status === 'running'
                    );

                    if (isRunning) {
                        console.log(`‚úÖ Server confirmed automation started for ${username}`);
                        return { success: true, waitTime: Date.now() - startTime };
                    }
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error checking server status:', error.message);
            }

            // Wait before next check
            await new Promise(resolve => setTimeout(resolve, checkInterval));
        }

        console.warn(`‚ö†Ô∏è Server start confirmation timeout after ${maxWaitTime}ms`);
        return { success: false, timeout: true, waitTime: Date.now() - startTime };
    }

    // Execution mode toggle
    function initExecutionModeToggle() {
        const radios = document.querySelectorAll('input[name="executionMode"]');
        const parallelOptions = document.getElementById('parallelOptions');

        radios.forEach(radio => {
            radio.addEventListener('change', function () {
                if (parallelOptions) {
                    parallelOptions.style.display = this.value === 'parallel' ? 'block' : 'none';
                }
            });
        });

        console.log('‚úÖ Execution mode toggle initialized');
    }

    // Promo type switching
    function initPromoTypeSwitching() {
        const radioButtons = document.querySelectorAll('input[name="promoType"]');

        radioButtons.forEach(radio => {
            radio.addEventListener('change', function () {
                const selectedType = this.value;
                console.log('Promo type changed to:', selectedType);

                const appGroup = document.getElementById('appPromoSites')?.closest('div[style*="margin-bottom: 25px"]');
                const smsGroup = document.getElementById('smsPromoSites')?.closest('div[style*="margin-bottom: 25px"]');

                if (selectedType === 'app') {
                    if (appGroup) appGroup.style.display = 'block';
                    if (smsGroup) smsGroup.style.display = 'none';
                } else {
                    if (appGroup) appGroup.style.display = 'none';
                    if (smsGroup) smsGroup.style.display = 'block';
                }
            });
        });

        // Trigger initial state
        const checkedRadio = document.querySelector('input[name="promoType"]:checked');
        if (checkedRadio) {
            checkedRadio.dispatchEvent(new Event('change'));
        }

        console.log('‚úÖ Promo type switching initialized');
    }

    // Tab switching (now handled by modal tabs)
    function initTabSwitching() {
        console.log('‚úÖ Tab switching initialized for modal');
    }



    // Toggle between App and SMS promo sites
    function togglePromoSites() {
        const promoType = document.querySelector('input[name="promoType"]:checked').value;
        const appGroup = document.getElementById('appPromoGroup');
        const smsGroup = document.getElementById('smsPromoGroup');

        if (promoType === 'app') {
            appGroup.style.display = 'block';
            smsGroup.style.display = 'none';
        } else {
            appGroup.style.display = 'none';
            smsGroup.style.display = 'block';
        }
    }

    // Clear form functions
    function clearAutoForm() {
        document.getElementById('autoUsername').value = '';
        document.getElementById('autoFullname').value = '';
        document.getElementById('autoPassword').value = '';
        document.getElementById('autoWithdrawPassword').value = '';
        document.getElementById('autoBankName').value = '';
        document.getElementById('autoBankBranch').value = '';
        document.getElementById('autoAccountNumber').value = '';
        document.querySelectorAll('#appPromoSites .site-check').forEach(cb => cb.checked = false);
        document.querySelectorAll('#smsPromoSites .site-check-sms').forEach(cb => cb.checked = false);
    }

    function clearRegisterForm() {
        document.getElementById('regUsername').value = '';
        document.getElementById('regFullname').value = '';
        document.getElementById('regPassword').value = '';
        document.getElementById('regWithdrawPassword').value = '';
        document.querySelectorAll('#appPromoSites .site-check').forEach(cb => cb.checked = false);
        document.querySelectorAll('#smsPromoSites .site-check-sms').forEach(cb => cb.checked = false);
    }

    function clearLoginForm() {
        document.getElementById('loginUsername').value = '';
        document.getElementById('loginPassword').value = '';
        document.querySelectorAll('#appPromoSites .site-check').forEach(cb => cb.checked = false);
        document.querySelectorAll('#smsPromoSites .site-check-sms').forEach(cb => cb.checked = false);
    }

    function clearBankForm() {
        document.getElementById('bankBankName').value = '';
        document.getElementById('bankBankBranch').value = '';
        document.getElementById('bankAccountNumber').value = '';
        document.querySelectorAll('#appPromoSites .site-check').forEach(cb => cb.checked = false);
        document.querySelectorAll('#smsPromoSites .site-check-sms').forEach(cb => cb.checked = false);
    }

    function clearPromoForm() {
        document.getElementById('promoUsername').value = '';
        document.querySelectorAll('#appPromoSites .site-check').forEach(cb => cb.checked = false);
        document.querySelectorAll('#smsPromoSites .site-check-sms').forEach(cb => cb.checked = false);
    }

    // Site selection - App Promo
    function selectAppPromoSites() {
        document.querySelectorAll('#appPromoSites .site-check').forEach(cb => cb.checked = true);
    }

    function deselectAppPromoSites() {
        document.querySelectorAll('#appPromoSites .site-check').forEach(cb => cb.checked = false);
    }

    // Site selection - SMS Promo
    function selectSmsPromoSites() {
        document.querySelectorAll('#smsPromoSites .site-check-sms').forEach(cb => cb.checked = true);
    }

    function deselectSmsPromoSites() {
        document.querySelectorAll('#smsPromoSites .site-check-sms').forEach(cb => cb.checked = false);
    }

    // Site selection - All (legacy support)
    function selectAllSites() {
        selectAppPromoSites();
        selectSmsPromoSites();
    }

    function deselectAllSites() {
        deselectAppPromoSites();
        deselectSmsPromoSites();
    }

    function getSelectedSites(action) {
        const sites = [];
        // Only get App sites (not SMS) for individual actions
        const appCheckboxes = document.querySelectorAll('#appPromoSites .site-check:checked');

        appCheckboxes.forEach(checkbox => {
            const name = checkbox.getAttribute('data-name');

            // All URLs will be handled by optimized-automation.js
            // Just pass site name, extension will get URLs from site config
            sites.push({ name });
        });
        return sites;
    }

    // Get selected sites by type (app or sms)
    function getSelectedSitesByType() {
        const appSites = [];
        const smsSites = [];

        // Get App Promo sites (optimized-automation.js will handle URLs)
        document.querySelectorAll('#appPromoSites .site-check:checked').forEach(checkbox => {
            const name = checkbox.getAttribute('data-name');
            appSites.push({ name });
        });

        // Get SMS Promo sites (optimized-automation.js will handle URLs)
        document.querySelectorAll('#smsPromoSites .site-check-sms:checked').forEach(checkbox => {
            const name = checkbox.getAttribute('data-name');
            smsSites.push({ name });
        });

        return { appSites, smsSites };
    }

    // Load banks
    async function loadBanksForTool() {
        const selects = ['autoBankName', 'bankBankName'];
        try {
            const response = await fetch('https://api.vietqr.io/v2/banks');
            const data = await response.json();
            if (data.code === '00' && data.data) {
                const sortedBanks = data.data.sort((a, b) => a.shortName.localeCompare(b.shortName));
                selects.forEach(selectId => {
                    const select = document.getElementById(selectId);
                    if (select) {
                        select.innerHTML = '<option value="">Ch·ªçn ng√¢n h√†ng...</option>';
                        sortedBanks.forEach(bank => {
                            const option = document.createElement('option');
                            option.value = bank.shortName;
                            option.textContent = `${bank.shortName} - ${bank.name}`;
                            select.appendChild(option);
                        });
                    }
                });
                console.log(`‚úÖ Loaded ${sortedBanks.length} banks`);
            }
        } catch (error) {
            console.error('‚ùå Failed to load banks:', error);
        }
    }

    // Random username generator
    const uniqueWords = {
        prefixes: ['Sky', 'Moon', 'Star', 'Fire', 'Dragon', 'Phoenix', 'Tiger', 'Wolf', 'Eagle', 'Lion'],
        suffixes: ['Blade', 'Strike', 'Storm', 'Fire', 'Bolt', 'Flash', 'Fury', 'Soul', 'Power'],
        numbers: ['', '1', '7', '9', '88', '99', '777', '888']
    };

    function generateRandomUsername() {
        const prefix = uniqueWords.prefixes[Math.floor(Math.random() * uniqueWords.prefixes.length)];
        const suffix = uniqueWords.suffixes[Math.floor(Math.random() * uniqueWords.suffixes.length)];
        const number = uniqueWords.numbers[Math.floor(Math.random() * uniqueWords.numbers.length)];
        return prefix + suffix + number;
    }



    // Random to√†n b·ªô form (username, fullname, password, bank)
    function randomAllForm() {
        // Random username
        const username = generateRandomUsername();
        document.getElementById('autoUsername').value = username;

        // Random fullname (Vietnamese names)
        const firstNames = ['NGUYEN', 'TRAN', 'LE', 'PHAM', 'HOANG', 'PHAN', 'VU', 'VO', 'DANG', 'BUI'];
        const middleNames = ['VAN', 'THI', 'DUC', 'MINH', 'HOANG', 'QUANG', 'ANH', 'THANH'];
        const lastNames = ['AN', 'BINH', 'CUONG', 'DUNG', 'HAI', 'HUNG', 'KHANH', 'LINH', 'MINH', 'NAM', 'PHONG', 'QUAN', 'TAM', 'TUAN', 'VINH'];

        const firstName = firstNames[Math.floor(Math.random() * firstNames.length)];
        const middleName = middleNames[Math.floor(Math.random() * middleNames.length)];
        const lastName = lastNames[Math.floor(Math.random() * lastNames.length)];
        const fullname = `${firstName} ${middleName} ${lastName}`;
        document.getElementById('autoFullname').value = fullname;

        // Random password (8-12 characters, guaranteed mix of letters and numbers)
        const passwordLength = 8 + Math.floor(Math.random() * 5); // 8-12 chars
        const letters = 'abcdefghijklmnopqrstuvwxyz';
        const numbers = '0123456789';

        let password = '';

        // Ensure at least 2 letters and 2 numbers
        password += letters[Math.floor(Math.random() * letters.length)];
        password += letters[Math.floor(Math.random() * letters.length)];
        password += numbers[Math.floor(Math.random() * numbers.length)];
        password += numbers[Math.floor(Math.random() * numbers.length)];

        // Fill remaining positions with random mix
        const allChars = letters + numbers;
        for (let i = 4; i < passwordLength; i++) {
            password += allChars[Math.floor(Math.random() * allChars.length)];
        }

        // Shuffle the password to avoid predictable pattern
        password = password.split('').sort(() => Math.random() - 0.5).join('');

        document.getElementById('autoPassword').value = password;

        // Random withdraw password (6 digits)
        const withdrawPassword = Math.floor(100000 + Math.random() * 900000).toString();
        document.getElementById('autoWithdrawPassword').value = withdrawPassword;

        // Random bank
        const bankSelect = document.getElementById('autoBankName');
        if (bankSelect && bankSelect.options.length > 1) {
            const randomIndex = 1 + Math.floor(Math.random() * (bankSelect.options.length - 1));
            bankSelect.selectedIndex = randomIndex;
        }

        // Random bank branch
        const branches = ['HO CHI MINH', 'HA NOI', 'DA NANG', 'CAN THO', 'HAI PHONG', 'BIEN HOA', 'NHA TRANG', 'VUNG TAU'];
        const branch = branches[Math.floor(Math.random() * branches.length)];
        document.getElementById('autoBankBranch').value = branch;

        // Random account number (10-14 digits)
        const accountLength = 10 + Math.floor(Math.random() * 5); // 10-14 digits
        let accountNumber = '';
        for (let i = 0; i < accountLength; i++) {
            accountNumber += Math.floor(Math.random() * 10);
        }
        document.getElementById('autoAccountNumber').value = accountNumber;

        // Visual feedback
        const inputs = [
            'autoUsername', 'autoFullname', 'autoPassword', 'autoWithdrawPassword',
            'autoBankName', 'autoBankBranch', 'autoAccountNumber'
        ];
        inputs.forEach(id => {
            const input = document.getElementById(id);
            if (input && input.value) {
                input.style.background = 'linear-gradient(135deg, #ebf4ff, #e0e7ff)';
                setTimeout(() => { input.style.background = ''; }, 1000);
            }
        });

        showToast('success', 'Random th√†nh c√¥ng', 'ƒê√£ random to√†n b·ªô th√¥ng tin');
    }

    // Run action based on current active tab
    function runCurrentTabAction() {
        const btn = document.getElementById('btnRunAction');
        if (btn) disableButton(btn);

        const activeTab = document.querySelector('.modal-tab.active');
        if (!activeTab) return;

        const tabName = activeTab.getAttribute('data-tab');

        // Enable button immediately after starting (not waiting for completion)
        if (btn) enableButton(btn);

        switch (tabName) {
            case 'auto':
                runAutoSequence();
                break;
            case 'register':
                runRegisterOnly();
                break;
            case 'login':
                runLoginOnly();
                break;
            case 'bank':
                runAddBankOnly();
                break;
            case 'promo':
                runCheckPromo();
                break;
        }
    }

    // Automation functions
    async function runAutoSequence() {
        // Disable button to prevent multiple clicks
        const btnRunAction = document.getElementById('btnRunAction');
        if (btnRunAction) {
            btnRunAction.disabled = true;
            btnRunAction.style.opacity = '0.5';
            btnRunAction.style.cursor = 'not-allowed';
        }

        try {
            if (!profileManager.selectedProfileId) {
                showToast('warning', 'Ch∆∞a ch·ªçn profile', 'Vui l√≤ng ch·ªçn profile t·ª´ sidebar');
                // Re-enable button on error
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
                return;
            }

            // Sync profile status from Hidemium before running
            console.log('üîÑ Syncing profile status from Hidemium...');
            await profileManager.loadAll();
            await loadProfilesCarousel();

            // Check if profile is already running
            if (profileManager.isRunning(profileManager.selectedProfileId)) {
                showToast('warning', 'Profile ƒëang ch·∫°y', 'Profile n√†y ƒëang ch·∫°y automation, vui l√≤ng ch·ªçn profile kh√°c');
                // Re-enable button on error
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
                return;
            }

            // Get selected promo type
            const promoType = document.querySelector('input[name="promoType"]:checked')?.value || 'app';
            console.log('Selected promo type:', promoType);

            // Get sites based on selected type
            let sites = [];
            let actionType = 'full'; // default for app

            if (promoType === 'app') {
                // Get App Promo sites - CENTRALIZED CONFIG (C√°ch 1)
                // Ch·ªâ pass name, URLs s·∫Ω ƒë∆∞·ª£c l·∫•y t·ª´ optimized-automation.js
                document.querySelectorAll('#appPromoSites .site-check:checked').forEach(checkbox => {
                    const name = checkbox.getAttribute('data-name');
                    sites.push({ name }); // Ch·ªâ pass name, kh√¥ng c·∫ßn URL
                });
                actionType = 'full'; // Full sequence with promo check
            } else {
                // Get SMS Promo sites - CENTRALIZED CONFIG (C√°ch 1)
                // Ch·ªâ pass name, URLs s·∫Ω ƒë∆∞·ª£c l·∫•y t·ª´ optimized-automation.js
                document.querySelectorAll('#smsPromoSites .site-check-sms:checked').forEach(checkbox => {
                    const name = checkbox.getAttribute('data-name');
                    sites.push({ name }); // Ch·ªâ pass name, kh√¥ng c·∫ßn URL
                });
                actionType = 'sms'; // SMS sequence (register + add bank only)
            }

            if (sites.length === 0) {
                showToast('warning', 'Ch∆∞a ch·ªçn trang', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 trang');
                // Re-enable button on error
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
                return;
            }

            const config = {
                username: document.getElementById('autoUsername').value.trim(),
                fullname: document.getElementById('autoFullname').value.trim(),
                password: document.getElementById('autoPassword').value.trim(),
                withdrawPassword: document.getElementById('autoWithdrawPassword').value.trim(),
                bankName: document.getElementById('autoBankName').value.trim(),
                bankBranch: document.getElementById('autoBankBranch').value.trim(),
                accountNumber: document.getElementById('autoAccountNumber').value.trim(),
                apiKey: apiKeyManager.get(),
                sites: sites,
                captchaDelay: parseInt(document.getElementById('autoCaptchaDelay')?.value ?? '0') * 1000
            };

            // Validate required fields
            if (!config.username || !config.password) {
                showToast('warning', 'Thi·∫øu th√¥ng tin', 'Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin');
                // Re-enable button on error
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
                return;
            }

            // Validate bank name (must be selected)
            if (!config.bankName || config.bankName === '') {
                showToast('warning', 'Thi·∫øu th√¥ng tin', 'Vui l√≤ng ch·ªçn ng√¢n h√†ng');
                // Re-enable button on error
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
                return;
            }

            // Validate account number (must be numbers only)
            if (config.accountNumber && !/^\d+$/.test(config.accountNumber)) {
                showToast('warning', 'S·ªë t√†i kho·∫£n kh√¥ng h·ª£p l·ªá', 'S·ªë t√†i kho·∫£n ch·ªâ ƒë∆∞·ª£c ch·ª©a ch·ªØ s·ªë');
                // Re-enable button on error
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
                return;
            }

            // Validate API key (required for captcha solving)
            const apiKey = config.apiKey;

            if (!apiKey || apiKey.trim() === '') {
                showToast('error', 'Thi·∫øu API Key', '‚ö†Ô∏è Vui l√≤ng th√™m Captcha API Key ·ªü sidebar b√™n tr√°i tr∆∞·ªõc khi ch·∫°y automation!\n\nüìù L·∫•y API key t·∫°i: autocaptcha.pro', 8000);
                // Re-enable button on error
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
                return;
            }

            // Validate API key format
            const apiValidation = validateApiKeyFormat(apiKey);
            if (!apiValidation.valid) {
                showToast('error', 'API Key kh√¥ng h·ª£p l·ªá', '‚ùå ' + apiValidation.error + '\n\nüí° Vui l√≤ng ki·ªÉm tra l·∫°i API Key ·ªü sidebar b√™n tr√°i!', 8000);
                // Re-enable button on error
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
                return;
            }

            console.log('‚úÖ API Key validated:', apiKey.substring(0, 10) + '...');

            // Add action type for SMS
            if (actionType === 'sms') {
                config.action = 'sms';
            } else {
                // Check if user enabled checkPromo
                const enableCheckPromo = document.getElementById('enableCheckPromo')?.checked ?? true;
                config.checkPromo = enableCheckPromo; // Enable/disable promo check based on checkbox
                console.log('üéÅ CheckPromo enabled:', enableCheckPromo);
            }

            const currentProfileId = profileManager.selectedProfileId;
            console.log('üéØ Selected Profile ID:', currentProfileId);
            console.log('üéØ Selected Profile Name:', profileManager.getSelected()?.name);

            // Mark profile as running
            profileManager.runningProfiles.add(currentProfileId);

            // Track start time to prevent premature sync removal
            if (!profileManager.runningStartTimes) {
                profileManager.runningStartTimes = new Map();
            }
            profileManager.runningStartTimes.set(currentProfileId, Date.now());

            profileManager.saveRunningProfiles();

            // Refresh carousel to show running status
            await loadProfilesCarousel();

            const promoTypeLabel = promoType === 'app' ? 'üì± T·∫£i App' : 'üí¨ SMS';
            // showToast('info', 'ƒêang ch·∫°y', `Automation ${promoTypeLabel} ƒëang ch·∫°y tr√™n ${sites.length} trang...`);

            try {
                // Get execution mode settings
                let executionMode = 'parallel'; // Default
                const radioChecked = document.querySelector('input[name="executionMode"]:checked');
                if (radioChecked) {
                    executionMode = radioChecked.value;
                }
                const parallelCountEl = document.getElementById('parallelCount');
                const parallelCount = parseInt(parallelCountEl?.value || '3');

                // Add execution mode to config
                config.executionMode = executionMode;
                config.parallelCount = executionMode === 'parallel' ? parallelCount : 1;

                console.log(`üöÄ Running ${promoType} sequence for ${sites.length} sites...`);
                console.log(`üîß Execution Mode: ${executionMode}, Parallel Count: ${config.parallelCount}`);

                // Use relative URL to automatically use current port
                console.log('üì§ Sending automation request with profileId:', currentProfileId);
                const response = await fetch('/api/automation/run', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ toolId: 'nohu-tool', profileId: currentProfileId, config: config })
                });
                const data = await response.json();

                if (data.success) {
                    // Wait for server to actually start automation
                    const waitResult = await waitForServerStart(config.username, 30000);

                    if (waitResult.success) {
                        showToast('success', 'ƒê√£ b·∫Øt ƒë·∫ßu', `Automation ${promoTypeLabel} ƒëang ch·∫°y trong background`, 5000);
                    } else {
                        showToast('success', 'ƒê√£ g·ª≠i', `Automation ${promoTypeLabel} ƒë√£ ƒë∆∞·ª£c g·ª≠i t·ªõi server`, 5000);
                    }

                    // Clear form after successful start
                    clearAutoForm();

                    // Refresh results table immediately to show running status
                    loadResultsFromServer();
                } else {
                    throw new Error(data.error || 'Unknown error');
                }

            } catch (error) {
                showToast('error', 'L·ªói', error.message);
                // Unmark on error
                profileManager.runningProfiles.delete(currentProfileId);
                profileManager.saveRunningProfiles();

                // Update card UI immediately to remove running status
                updateProfileCardStatus(currentProfileId);

                await loadProfilesCarousel();
            } finally {
                // Re-enable button after waiting for server confirmation
                const btnRunAction = document.getElementById('btnRunAction');
                if (btnRunAction) {
                    btnRunAction.disabled = false;
                    btnRunAction.style.opacity = '1';
                    btnRunAction.style.cursor = 'pointer';
                }
            }

            // Note: Profile will be unmarked when user manually stops it or restarts dashboard
            // For auto-unmark when done, need server-side callback (future enhancement)
        } catch (error) {
            console.error('‚ùå Outer try-catch error:', error);
            showToast('error', 'L·ªói', error.message);
            // Unmark on error
            const profileId = profileManager.selectedProfileId;
            profileManager.runningProfiles.delete(profileId);
            profileManager.saveRunningProfiles();

            // Update card UI immediately to remove running status
            updateProfileCardStatus(profileId);

            await loadProfilesCarousel();
        } finally {
            // Re-enable button if not already enabled
            const btnRunAction = document.getElementById('btnRunAction');
            if (btnRunAction && btnRunAction.disabled) {
                btnRunAction.disabled = false;
                btnRunAction.style.opacity = '1';
                btnRunAction.style.cursor = 'pointer';
            }
        }
    }

    // Helper function to run automation with profile marking
    async function runAutomationWithMarking(toolId, action, config) {
        console.log('üöÄ runAutomationWithMarking called:', { toolId, action });

        const currentProfileId = profileManager.selectedProfileId;

        // Sync profile status from Hidemium before running
        console.log('üîÑ Syncing profile status from Hidemium...');
        await profileManager.loadAll();
        await loadProfilesCarousel();

        // Check if already running
        if (profileManager.isRunning(currentProfileId)) {
            showToast('warning', 'Profile ƒëang ch·∫°y', 'Profile n√†y ƒëang ch·∫°y automation, vui l√≤ng ch·ªçn profile kh√°c');
            return { success: false };
        }

        // Mark as running
        profileManager.runningProfiles.add(currentProfileId);

        // Track start time to prevent premature sync removal
        if (!profileManager.runningStartTimes) {
            profileManager.runningStartTimes = new Map();
        }
        profileManager.runningStartTimes.set(currentProfileId, Date.now());

        profileManager.saveRunningProfiles();

        // Update card UI immediately to show running status
        updateProfileCardStatus(currentProfileId);

        await loadProfilesCarousel();

        try {
            // Get execution mode settings with multiple fallbacks
            let executionMode = 'parallel'; // Default

            // Try to get from radio button
            const radioChecked = document.querySelector('input[name="executionMode"]:checked');
            if (radioChecked) {
                executionMode = radioChecked.value;
                console.log('üîß Got executionMode from radio:', executionMode);
            } else {
                // Fallback: try to find any radio with that name
                const allRadios = document.querySelectorAll('input[name="executionMode"]');
                console.log('üîß Found radios:', allRadios.length);
                allRadios.forEach((r, i) => {
                    console.log(`  Radio ${i}: value=${r.value}, checked=${r.checked}`);
                    if (r.checked) executionMode = r.value;
                });
            }

            const parallelCountEl = document.getElementById('parallelCount');
            const parallelCount = parseInt(parallelCountEl?.value || '3');

            console.log('üîß Final Execution Mode:', executionMode);
            console.log('üîß Parallel Count:', parallelCount);

            // Build final config with execution mode
            const finalConfig = {
                ...config,
                action,
                executionMode: executionMode,
                parallelCount: executionMode === 'parallel' ? parallelCount : 1
            };

            console.log('üîß Final config:', JSON.stringify(finalConfig, null, 2));

            // Use relative URL to automatically use current port
            const response = await fetch('/api/automation/run', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    toolId,
                    profileId: currentProfileId,
                    config: finalConfig
                })
            });
            const data = await response.json();

            if (data.success) {
                showToast('success', 'ƒê√£ b·∫Øt ƒë·∫ßu', 'Automation ƒëang ch·∫°y trong background', 5000);

                // Clear form based on action
                switch (action) {
                    case 'registerOnly':
                        clearRegisterForm();
                        break;
                    case 'loginOnly':
                        clearLoginForm();
                        break;
                    case 'addBankOnly':
                        clearBankForm();
                        break;
                    case 'checkPromoOnly':
                        clearPromoForm();
                        break;
                }

                return { success: true };
            } else {
                throw new Error(data.error || 'Unknown error');
            }
        } catch (error) {
            showToast('error', 'L·ªói', error.message);

            // Unmark on error
            profileManager.runningProfiles.delete(currentProfileId);
            profileManager.saveRunningProfiles();

            // Update card UI immediately to remove running status
            updateProfileCardStatus(currentProfileId);

            await loadProfilesCarousel();
            return { success: false };
        }
    }

    async function runRegisterOnly() {
        // Validate
        if (!profileManager.selectedProfileId) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ch·ªçn profile');
            return;
        }

        const sites = getSelectedSites();
        if (sites.length === 0) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 trang');
            return;
        }

        const username = document.getElementById('registerUsername').value.trim();
        const password = document.getElementById('registerPassword').value.trim();
        const fullname = document.getElementById('registerFullname').value.trim();
        const withdrawPassword = document.getElementById('registerWithdrawPassword').value.trim();

        if (!username || !password || !fullname || !withdrawPassword) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ƒëi·ªÅn ƒë·∫ßy ƒë·ªß th√¥ng tin');
            return;
        }

        // Validate API key (required for captcha solving during registration)
        const apiKey = apiKeyManager.get();
        if (!apiKey || apiKey.trim() === '') {
            showToast('error', 'Thi·∫øu API Key', '‚ö†Ô∏è Vui l√≤ng th√™m Captcha API Key ·ªü sidebar tr∆∞·ªõc khi ƒëƒÉng k√Ω!\n\nüìù L·∫•y API key t·∫°i: autocaptcha.pro', 8000);
            return;
        }

        const apiValidation = validateApiKeyFormat(apiKey);
        if (!apiValidation.valid) {
            showToast('error', 'API Key kh√¥ng h·ª£p l·ªá', '‚ùå ' + apiValidation.error + '\n\nüí° Vui l√≤ng ki·ªÉm tra l·∫°i API Key!', 8000);
            return;
        }

        console.log('‚úÖ API Key validated for registration:', apiKey.substring(0, 10) + '...');

        const fullSites = sites.map(site => ({
            name: site.name,
            registerUrl: site.registerUrl,
            url: site.registerUrl
        }));

        // showToast('info', 'ƒêang ch·∫°y', `ƒêƒÉng k√Ω tr√™n ${sites.length} trang...`);

        await runAutomationWithMarking('nohu-tool', 'registerOnly', {
            username,
            password,
            fullname,
            withdrawPassword,
            apiKey: apiKeyManager.get(),
            sites: fullSites
        });
    }

    async function runLoginOnly() {
        // Validate
        if (!profileManager.selectedProfileId) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ch·ªçn profile');
            return;
        }

        const sites = getSelectedSites();
        if (sites.length === 0) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 trang');
            return;
        }

        const username = document.getElementById('loginUsername').value.trim();
        const password = document.getElementById('loginPassword').value.trim();

        if (!username || !password) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ƒëi·ªÅn username v√† password');
            return;
        }

        // Validate API key (required for captcha solving during login)
        const apiKey = apiKeyManager.get();
        if (!apiKey || apiKey.trim() === '') {
            showToast('error', 'Thi·∫øu API Key', '‚ö†Ô∏è Vui l√≤ng th√™m Captcha API Key ·ªü sidebar tr∆∞·ªõc khi ƒëƒÉng nh·∫≠p!\n\nüìù L·∫•y API key t·∫°i: autocaptcha.pro', 8000);
            return;
        }

        const apiValidation = validateApiKeyFormat(apiKey);
        if (!apiValidation.valid) {
            showToast('error', 'API Key kh√¥ng h·ª£p l·ªá', '‚ùå ' + apiValidation.error + '\n\nüí° Vui l√≤ng ki·ªÉm tra l·∫°i API Key!', 8000);
            return;
        }

        console.log('‚úÖ API Key validated for login:', apiKey.substring(0, 10) + '...');

        const fullSites = sites.map(site => ({
            name: site.name,
            loginUrl: site.loginUrl,
            url: site.loginUrl
        }));

        // showToast('info', 'ƒêang ch·∫°y', `ƒêƒÉng nh·∫≠p v√†o ${sites.length} trang...`);

        await runAutomationWithMarking('nohu-tool', 'loginOnly', {
            username,
            password,
            apiKey: apiKeyManager.get(),
            sites: fullSites
        });
    }

    async function runAddBankOnly() {
        // Validate
        if (!profileManager.selectedProfileId) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ch·ªçn profile');
            return;
        }

        const sites = getSelectedSites();
        if (sites.length === 0) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 trang');
            return;
        }

        const bankName = document.getElementById('bankBankName').value.trim();
        const bankBranch = document.getElementById('bankBankBranch').value.trim();
        const accountNumber = document.getElementById('bankAccountNumber').value.trim();

        if (!bankName || !accountNumber) {
            showToast('error', 'L·ªói', 'Vui l√≤ng ch·ªçn ng√¢n h√†ng v√† nh·∫≠p s·ªë t√†i kho·∫£n');
            return;
        }

        const fullSites = sites.map(site => ({
            name: site.name,
            loginUrl: site.loginUrl,
            url: site.loginUrl
        }));

        // showToast('info', 'ƒêang ch·∫°y', `Th√™m ng√¢n h√†ng cho ${sites.length} trang...`);

        // Store initial form values to detect success
        const initialBankName = bankName;
        const initialAccountNumber = accountNumber;

        await runAutomationWithMarking('nohu-tool', 'addBankOnly', {
            bankName,
            bankBranch,
            accountNumber,
            apiKey: apiKeyManager.get(),
            sites: fullSites,
            // Pass initial values to detect success
            _initialBankName: initialBankName,
            _initialAccountNumber: initialAccountNumber
        });

        // Monitor form to detect success (form cleared = success)
        monitorFormForSuccess('bank', {
            bankName: initialBankName,
            accountNumber: initialAccountNumber
        });
    }

    // Monitor form values to detect automation success
    // Success = form values are populated (not empty) after automation
    function monitorFormForSuccess(formType, initialValues) {
        let checkCount = 0;
        const maxChecks = 120; // Check for 2 minutes (120 * 1s)

        const interval = setInterval(() => {
            checkCount++;

            if (formType === 'bank') {
                const currentBankName = document.getElementById('bankBankName').value.trim();
                const currentAccountNumber = document.getElementById('bankAccountNumber').value.trim();

                // Success detected if form values are populated (not empty)
                // This means the form was reloaded with data after automation
                if (currentBankName !== '' && currentAccountNumber !== '') {
                    console.log('‚úÖ Form values populated - automation succeeded!');
                    console.log(`   Bank: ${currentBankName}`);
                    console.log(`   Account: ${currentAccountNumber}`);
                    showToast('success', 'Th√™m Bank Th√†nh C√¥ng', `${currentBankName} - ${currentAccountNumber}`);
                    clearInterval(interval);
                    return;
                }
            }

            // Stop checking after max attempts
            if (checkCount >= maxChecks) {
                console.log('‚è±Ô∏è Form monitoring timeout');
                clearInterval(interval);
            }
        }, 1000); // Check every 1 second
    }

    async function runCheckPromo() {
        console.log('üéÅ runCheckPromo() called');

        if (!profileManager.selectedProfileId) {
            showToast('warning', 'Ch∆∞a ch·ªçn profile', 'Vui l√≤ng ch·ªçn profile t·ª´ sidebar');
            return;
        }
        const sites = getSelectedSites('promo');
        if (sites.length === 0) {
            showToast('warning', 'Ch∆∞a ch·ªçn trang', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 trang');
            return;
        }
        const username = document.getElementById('promoUsername').value;

        if (!username) {
            showToast('warning', 'Thi·∫øu th√¥ng tin', 'Vui l√≤ng nh·∫≠p t√™n t√†i kho·∫£n');
            return;
        }

        // Validate API key (required for captcha solving in check promo)
        const apiKey = apiKeyManager.get();
        if (!apiKey || apiKey.trim() === '') {
            showToast('error', 'Thi·∫øu API Key', '‚ö†Ô∏è Vui l√≤ng th√™m Captcha API Key ·ªü sidebar tr∆∞·ªõc khi check khuy·∫øn m√£i!\n\nüìù L·∫•y API key t·∫°i: autocaptcha.pro', 8000);
            return;
        }

        const apiValidation = validateApiKeyFormat(apiKey);
        if (!apiValidation.valid) {
            showToast('error', 'API Key kh√¥ng h·ª£p l·ªá', '‚ùå ' + apiValidation.error + '\n\nüí° Vui l√≤ng ki·ªÉm tra l·∫°i API Key ·ªü sidebar!', 8000);
            return;
        }

        console.log('‚úÖ API Key validated for check promo:', apiKey.substring(0, 10) + '...');

        // Get captcha delay from left column (shared for both tabs)
        const captchaDelay = parseInt(document.getElementById('autoCaptchaDelay')?.value || '0') * 1000;
        console.log('‚è±Ô∏è Captcha delay:', captchaDelay, 'ms');

        // Convert sites to full format with promoUrl
        const fullSites = sites.map(site => ({
            name: site.name,
            registerUrl: site.url,
            loginUrl: site.url,
            promoUrl: site.url
        }));

        // showToast('info', 'ƒêang ch·∫°y', `Check khuy·∫øn m√£i tr√™n ${sites.length} trang...`);

        try {
            await runAutomationWithMarking('nohu-tool', 'checkPromoOnly', {
                username: username,
                apiKey: apiKeyManager.get(), // Required for captcha solving
                checkPromo: true,
                captchaDelay: captchaDelay,
                sites: fullSites
            });
        } catch (error) {
            console.error('‚ùå Check promo error:', error);
            showToast('error', 'L·ªói', error.message);
        }

        // Refresh results table after check promo completes
        // Add delay to ensure server has processed the completion status
        setTimeout(() => {
            console.log('üîÑ Refreshing results table after check promo...');
            loadResultsFromServer();
        }, 1000);
    }

    // ============================================
    // PROFILE CAROUSEL
    // ============================================

    let allProfilesData = [];

    async function loadProfilesCarousel(showNotification = false) {
        const result = await profileManager.loadAll();

        if (result.success && result.profiles) {
            allProfilesData = result.profiles;

            // Update all carousels
            const carousels = ['auto', 'reg', 'login', 'bank', 'promo'];

            carousels.forEach(tabPrefix => {
                displayProfilesInCarousel(tabPrefix, allProfilesData);
            });

            if (showNotification) {
                showToast('success', 'ƒê√£ t·∫£i l·∫°i', `${allProfilesData.length} profiles`);
            }
            console.log(`‚úÖ Loaded ${allProfilesData.length} profiles into carousels`);
        } else {
            if (showNotification) {
                showToast('error', 'L·ªói t·∫£i profiles', result.error);
            }
            console.error('‚ùå Failed to load profiles:', result.error);
        }
    }

    function displayProfilesInCarousel(tabPrefix, profiles) {
        const carousel = document.getElementById(`${tabPrefix}ProfileCarousel`);
        if (!carousel) return;

        carousel.innerHTML = '';

        if (profiles.length === 0) {
            carousel.innerHTML = '<div class="profile-carousel-empty"><p>Ch∆∞a c√≥ profiles</p></div>';
            return;
        }

        profiles.forEach(profile => {
            const isRunning = profileManager.isRunning(profile.uuid);
            const isSelected = profileManager.selectedProfileId === profile.uuid;

            // Extract proxy IP
            let proxyIP = 'No proxy';
            if (profile.proxy && typeof profile.proxy === 'object' && profile.proxy.ip) {
                proxyIP = profile.proxy.ip;
            } else if (profile.proxy && typeof profile.proxy === 'string') {
                const parts = profile.proxy.split('|');
                if (parts.length >= 2 && parts[1]) {
                    proxyIP = parts[1];
                }
            }

            // OS & Browser icons
            const osIcons = { 'win': 'ü™ü', 'windows': 'ü™ü', 'mac': 'üçé', 'macos': 'üçé', 'linux': 'üêß', 'android': 'ü§ñ', 'ios': 'üì±' };
            const browserIcons = { 'chrome': 'üåê', 'firefox': 'ü¶ä', 'edge': 'üî∑', 'opera': 'üî¥', 'brave': 'ü¶Å', 'safari': 'üß≠' };
            const osIcon = osIcons[profile.os?.toLowerCase()] || 'üíª';
            const browserIcon = browserIcons[profile.browser?.toLowerCase()] || 'üåê';

            const card = document.createElement('div');
            card.className = `profile-carousel-card ${isSelected ? 'selected' : ''} ${isRunning ? 'running' : ''}`;
            card.setAttribute('data-uuid', profile.uuid);
            card.setAttribute('data-tab', tabPrefix);

            card.innerHTML = `
                <div class="profile-card-header">
                    <div class="profile-avatar">
                        ${profile.name ? profile.name.substring(0, 2).toUpperCase() : 'PR'}
                    </div>
                    ${isRunning ? '<span class="running-badge">‚óè Running</span>' : ''}
                    ${isSelected ? '<span class="selected-badge">‚úì Selected</span>' : ''}
                </div>
                <div class="profile-card-body">
                    <div class="profile-card-name">${profile.name || 'Unnamed Profile'}</div>
                    <div class="profile-card-info">
                        <div class="info-item">
                            <span class="info-icon">${osIcon}</span>
                            <span class="info-text">${profile.os || 'N/A'}</span>
                        </div>
                        <div class="info-item">
                            <span class="info-icon">${browserIcon}</span>
                            <span class="info-text">${profile.browser || 'chrome'}</span>
                        </div>
                        <div class="info-item">
                            <span class="info-icon">üåç</span>
                            <span class="info-text">${proxyIP}</span>
                        </div>
                    </div>
                </div>
                <div class="profile-card-footer">
                    <div class="profile-status-text ${isRunning ? 'running' : (isSelected ? 'selected' : 'available')}">
                        ${isRunning ? 'üî¥ ƒêang Ch·∫°y' : (isSelected ? '‚úì ƒê√£ Ch·ªçn' : 'üëÜ Click ƒë·ªÉ ch·ªçn')}
                    </div>
                </div>
            `;

            // Add click event listener to entire card
            if (!isRunning) {
                card.style.cursor = 'pointer';
                card.addEventListener('click', () => {
                    selectProfileFromCarousel(tabPrefix, profile.uuid);
                });
            } else {
                card.style.cursor = 'not-allowed';
                card.addEventListener('click', () => {
                    showToast('warning', 'Profile ƒëang ch·∫°y', 'Kh√¥ng th·ªÉ ch·ªçn profile ƒëang ch·∫°y automation');
                });
            }

            carousel.appendChild(card);
        });

        // Re-enable drag scroll after rendering profiles
        enableDragScroll(carousel);
    }

    function selectProfileFromCarousel(tabPrefix, uuid) {
        // Check if profile is running
        if (profileManager.isRunning(uuid)) {
            showToast('warning', 'Profile ƒëang ch·∫°y', 'Kh√¥ng th·ªÉ ch·ªçn profile ƒëang ch·∫°y automation');
            return;
        }

        // Select in manager
        profileManager.select(uuid);

        // Update all carousels to show selected state
        const carousels = ['auto', 'reg', 'login', 'bank', 'promo'];
        carousels.forEach(prefix => {
            const carousel = document.getElementById(`${prefix}ProfileCarousel`);
            if (carousel) {
                // Remove selected class from all cards and update status text
                carousel.querySelectorAll('.profile-carousel-card').forEach(card => {
                    card.classList.remove('selected');
                    const statusText = card.querySelector('.profile-status-text');
                    const selectedBadge = card.querySelector('.selected-badge');

                    if (statusText) {
                        const cardUuid = card.getAttribute('data-uuid');
                        const isRunning = profileManager.isRunning(cardUuid);

                        if (isRunning) {
                            statusText.textContent = 'üî¥ ƒêang Ch·∫°y';
                            statusText.className = 'profile-status-text running';
                        } else {
                            statusText.textContent = 'üëÜ Click ƒë·ªÉ ch·ªçn';
                            statusText.className = 'profile-status-text available';
                        }
                    }

                    // Remove selected badge
                    if (selectedBadge) {
                        selectedBadge.remove();
                    }
                });

                // Add selected class to clicked card and update its status
                const selectedCard = carousel.querySelector(`[data-uuid="${uuid}"]`);
                if (selectedCard) {
                    selectedCard.classList.add('selected');
                    const statusText = selectedCard.querySelector('.profile-status-text');
                    if (statusText) {
                        statusText.textContent = '‚úì ƒê√£ Ch·ªçn';
                        statusText.className = 'profile-status-text selected';
                    }

                    // Add selected badge
                    const header = selectedCard.querySelector('.profile-card-header');
                    if (header && !header.querySelector('.selected-badge')) {
                        const badge = document.createElement('span');
                        badge.className = 'selected-badge';
                        badge.textContent = '‚úì Selected';
                        header.appendChild(badge);
                    }
                }
            }
        });

        const profile = profileManager.getSelected();
        showToast('success', 'Profile ƒë√£ ch·ªçn', profile?.name || 'Unknown');
    }

    // Update profile card UI status without reloading entire carousel
    function updateProfileCardStatus(profileId) {
        const carousels = ['auto', 'reg', 'login', 'bank', 'promo'];
        const isRunning = profileManager.isRunning(profileId);

        carousels.forEach(tabPrefix => {
            const carousel = document.getElementById(`${tabPrefix}ProfileCarousel`);
            if (!carousel) return;

            const card = carousel.querySelector(`[data-uuid="${profileId}"]`);
            if (!card) return;

            if (isRunning) {
                // Add running class and badge
                card.classList.add('running');

                // Update or add running badge
                let runningBadge = card.querySelector('.running-badge');
                if (!runningBadge) {
                    const header = card.querySelector('.profile-card-header');
                    if (header) {
                        runningBadge = document.createElement('span');
                        runningBadge.className = 'running-badge';
                        runningBadge.textContent = '‚óè Running';
                        header.appendChild(runningBadge);
                    }
                }

                // Update status text
                const statusText = card.querySelector('.profile-status-text');
                if (statusText) {
                    statusText.textContent = 'üî¥ ƒêang Ch·∫°y';
                    statusText.className = 'profile-status-text running';
                }

                // Disable click
                card.style.cursor = 'not-allowed';
            } else {
                // Remove running class and badge
                card.classList.remove('running');
                const runningBadge = card.querySelector('.running-badge');
                if (runningBadge) {
                    runningBadge.remove();
                }

                // Update status text
                const statusText = card.querySelector('.profile-status-text');
                if (statusText) {
                    const isSelected = profileManager.selectedProfileId === profileId;
                    if (isSelected) {
                        statusText.textContent = '‚úì ƒê√£ Ch·ªçn';
                        statusText.className = 'profile-status-text selected';
                    } else {
                        statusText.textContent = 'üëÜ Click ƒë·ªÉ ch·ªçn';
                        statusText.className = 'profile-status-text available';
                    }
                }

                // Enable click
                card.style.cursor = 'pointer';
            }
        });
    }

    function scrollProfileCarousel(tabPrefix, direction) {
        const carousel = document.getElementById(`${tabPrefix}ProfileCarousel`);
        console.log('Scroll carousel:', tabPrefix, direction, carousel);

        if (!carousel) {
            console.error('Carousel not found:', `${tabPrefix}ProfileCarousel`);
            return;
        }

        const cardWidth = 350; // 320px card + 30px gap
        const scrollAmount = cardWidth * direction;

        console.log('Scrolling by:', scrollAmount);

        carousel.scrollBy({
            left: scrollAmount,
            behavior: 'smooth'
        });

        // Update card states after scroll
        setTimeout(() => updateCarouselCardStates(tabPrefix), 400);
    }

    function updateCarouselCardStates(tabPrefix) {
        const carousel = document.getElementById(`${tabPrefix}ProfileCarousel`);
        if (!carousel) return;

        const cards = carousel.querySelectorAll('.profile-carousel-card');
        const carouselRect = carousel.getBoundingClientRect();
        const carouselCenter = carouselRect.left + carouselRect.width / 2;

        cards.forEach(card => {
            const cardRect = card.getBoundingClientRect();
            const cardCenter = cardRect.left + cardRect.width / 2;
            const distance = Math.abs(carouselCenter - cardCenter);

            // Card is in center view if distance is small
            if (distance < 200) {
                card.classList.add('in-view');
            } else {
                card.classList.remove('in-view');
            }
        });
    }

    // ============================================
    // DRAG TO SCROLL
    // ============================================

    function enableDragScroll(carousel) {
        let isDown = false;
        let startX;
        let scrollLeft;

        // Mouse events
        carousel.addEventListener('mousedown', (e) => {
            // Don't drag if clicking on button
            if (e.target.closest('.btn-select-profile')) return;

            isDown = true;
            carousel.style.cursor = 'grabbing';
            carousel.style.userSelect = 'none';
            startX = e.pageX - carousel.offsetLeft;
            scrollLeft = carousel.scrollLeft;
        });

        carousel.addEventListener('mouseleave', () => {
            isDown = false;
            carousel.style.cursor = 'grab';
        });

        carousel.addEventListener('mouseup', () => {
            isDown = false;
            carousel.style.cursor = 'grab';
        });

        carousel.addEventListener('mousemove', (e) => {
            if (!isDown) return;
            e.preventDefault();
            const x = e.pageX - carousel.offsetLeft;
            const walk = (x - startX) * 2; // Scroll speed
            carousel.scrollLeft = scrollLeft - walk;
        });

        // Touch events for mobile/tablet
        carousel.addEventListener('touchstart', (e) => {
            startX = e.touches[0].pageX - carousel.offsetLeft;
            scrollLeft = carousel.scrollLeft;
        });

        carousel.addEventListener('touchmove', (e) => {
            const x = e.touches[0].pageX - carousel.offsetLeft;
            const walk = (x - startX) * 2; // Same scroll speed
            carousel.scrollLeft = scrollLeft - walk;
        });

        // Wheel scroll
        carousel.addEventListener('wheel', (e) => {
            e.preventDefault();
            carousel.scrollBy({
                left: e.deltaY < 0 ? -100 : 100,
                behavior: 'smooth'
            });
        });

        // Set initial cursor
        carousel.style.cursor = 'grab';
    }

    // Update card states on scroll and enable drag
    document.addEventListener('DOMContentLoaded', () => {
        const carousels = ['auto', 'reg', 'login', 'bank', 'promo'];
        carousels.forEach(prefix => {
            const carousel = document.getElementById(`${prefix}ProfileCarousel`);
            if (carousel) {
                // Enable scroll update
                carousel.addEventListener('scroll', () => {
                    updateCarouselCardStates(prefix);
                });

                // Enable drag to scroll
                enableDragScroll(carousel);
            }
        });
    });

    // ============================================
    // RESULTS TABLE MANAGEMENT - GROUPED BY USERNAME
    // ============================================

    // Store results grouped by username
    const resultsData = {};

    // Track processed result IDs to avoid duplicates

    // Pagination state
    let currentPage = 1;
    let pageSize = 4; // Fixed: 4 rows per page
    let totalResults = 0;
    let allResultsKeys = []; // Store all sorted keys
    const processedResults = new Set();

    // Calculate optimal page size based on available height
    function calculateOptimalPageSize() {
        // Use fixed row height estimate
        const rowHeight = 65; // Approximate height per row
        const paginationHeight = 70;
        const theadHeight = 50;
        const headerHeight = 60; // Results header

        // Get available height from tool-content
        const toolContent = document.querySelector('.tool-content');
        if (!toolContent) {
            console.log('‚ö†Ô∏è tool-content not found, using default');
            return 10;
        }

        const totalHeight = toolContent.clientHeight;
        const availableHeight = totalHeight - headerHeight - theadHeight - paginationHeight - 150; // 150px buffer for safety

        const maxRows = Math.floor(availableHeight / rowHeight);
        const calculatedSize = Math.max(5, Math.min(maxRows, 50));

        console.log('üìä PageSize calculation:', {
            totalHeight,
            availableHeight,
            rowHeight,
            maxRows,
            calculatedSize
        });

        return calculatedSize;
    }

    // Add result to table (grouped by username + sessionId)
    function addResultToTable(result) {
        // Create unique ID for this result
        const resultId = `${result.profileName}_${result.username}_${result.sessionId}_${result.siteName}_${result.timestamp}`;

        // Skip if already processed
        if (processedResults.has(resultId)) {
            return;
        }

        processedResults.add(resultId);
        const username = result.username || 'N/A';
        const sessionId = result.sessionId || 'default';
        const key = `${username}_${sessionId}`; // Group by username + sessionId (each run is separate)

        // Initialize group if not exists
        if (!resultsData[key]) {
            resultsData[key] = {
                profileName: result.profileName,
                username: username,
                sessionId: sessionId, // Store sessionId for deletion
                runNumber: result.runNumber || null, // Store run number from metadata
                hasAccountInfo: result.hasAccountInfo !== false, // Flag to show account info button
                sites: [],
                screenshots: [],
                checkTimes: [], // Track each check session
                firstTimestamp: result.timestamp || Date.now(),
                lastTimestamp: result.timestamp || Date.now()
            };
        }

        // Add site result
        resultsData[key].sites.push({
            name: result.siteName,
            status: result.status,
            screenshot: result.screenshot,
            timestamp: result.timestamp || Date.now()
        });

        // Add screenshot if exists
        if (result.screenshot) {
            resultsData[key].screenshots.push({
                site: result.siteName,
                url: result.screenshot,
                timestamp: result.timestamp || Date.now()
            });
        }

        // Track check times (group by day to count separate check sessions)
        const checkDate = new Date(result.timestamp || Date.now()).toDateString();
        if (!resultsData[key].checkTimes.includes(checkDate)) {
            resultsData[key].checkTimes.push(checkDate);
        }

        // Update last timestamp
        resultsData[key].lastTimestamp = result.timestamp || Date.now();

        // Refresh table display
        refreshResultsTable();
    }

    // Refresh table display
    function refreshResultsTable() {
        const tbody = document.getElementById('resultsTableBody');
        if (!tbody) return;

        // Clear table
        tbody.innerHTML = '';

        // Check if empty
        if (Object.keys(resultsData).length === 0) {
            tbody.innerHTML = `
                <tr>
                    <td colspan="8" style="text-align: center; color: #a0aec0; padding: 40px;">
                        Ch∆∞a c√≥ k·∫øt qu·∫£. Ch·∫°y automation ƒë·ªÉ xem k·∫øt qu·∫£ ·ªü ƒë√¢y.
                    </td>
                </tr>
            `;
            document.getElementById('paginationControls').style.display = 'none';
            return;
        }

        // Sort by: running first, then by last timestamp (newest first)
        const sortedKeys = Object.keys(resultsData).sort((a, b) => {
            const aRunning = resultsData[a].status === 'running' ? 0 : 1;
            const bRunning = resultsData[b].status === 'running' ? 0 : 1;

            // If both running or both not running, sort by timestamp
            if (aRunning === bRunning) {
                return resultsData[b].lastTimestamp - resultsData[a].lastTimestamp;
            }

            // Running entries come first
            return aRunning - bRunning;
        });

        console.log(`üîÑ refreshResultsTable called: ${sortedKeys.length} entries`);
        sortedKeys.forEach(key => {
            const entry = resultsData[key];
            console.log(`  - ${key}: status=${entry.status}, message="${entry.message}"`);
        });

        // Store previous total for comparison
        const previousTotal = totalResults;
        const newTotal = sortedKeys.length;

        // Store for pagination
        allResultsKeys = sortedKeys;

        // Calculate total pages
        const totalPages = Math.ceil(newTotal / pageSize);

        // Only update totalResults and handle pagination if there's a real change
        if (newTotal !== previousTotal) {
            totalResults = newTotal;

            if (newTotal > previousTotal) {
                // New results added - only reset to page 1 if this is NOT an auto-refresh
                // Check if this is called from loadResultsFromServer (auto-refresh)
                const isAutoRefresh = window.isAutoRefreshInProgress;

                if (!isAutoRefresh && currentPage !== 1) {
                    currentPage = 1;
                    console.log('üÜï New results detected, reset to page 1');
                } else if (isAutoRefresh) {
                    console.log('üîÑ Auto-refresh detected new results, keeping current page:', currentPage);
                }
            } else if (newTotal < previousTotal) {
                // Results decreased (deletion) - adjust page if needed
                if (currentPage > totalPages && totalPages > 0) {
                    currentPage = totalPages;
                    console.log('üìÑ Current page out of range after deletion, adjusted to:', currentPage);
                } else {
                    console.log('üóëÔ∏è Results decreased (deletion), keeping current page:', currentPage);
                }
            }
        } else {
            // Same number of results - keep current page (normal polling refresh)
            // Just ensure page is still valid
            if (currentPage > totalPages && totalPages > 0) {
                currentPage = totalPages;
                console.log('üìÑ Current page out of range, adjusted to:', currentPage);
            }
        }

        // Group sessions by username and sort by timestamp to get run order
        const sessionsByUsername = {};
        sortedKeys.forEach(key => {
            const group = resultsData[key];
            const username = group.username;
            if (!sessionsByUsername[username]) {
                sessionsByUsername[username] = [];
            }
            sessionsByUsername[username].push({
                key: key,
                timestamp: group.firstTimestamp || group.lastTimestamp
            });
        });

        // Get run number from metadata (stored when session was created)
        const runNumberByKey = {};
        Object.keys(resultsData).forEach(key => {
            const group = resultsData[key];
            // Use runNumber from metadata if available
            if (group.runNumber) {
                runNumberByKey[key] = group.runNumber;
            }
        });

        // For sessions without runNumber in metadata (old data), calculate based on index
        Object.keys(sessionsByUsername).forEach(username => {
            const sessions = sessionsByUsername[username];
            sessions.sort((a, b) => a.timestamp - b.timestamp);

            sessions.forEach((session, index) => {
                // Only set if not already set from metadata
                if (!runNumberByKey[session.key]) {
                    runNumberByKey[session.key] = index + 1;
                }
            });
        });

        // Ensure currentPage is within valid range (totalPages already calculated above)
        if (currentPage > totalPages) {
            currentPage = totalPages;
        }
        if (currentPage < 1) {
            currentPage = 1;
        }

        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = Math.min(startIndex + pageSize, totalResults);

        // Get current page items
        const pageKeys = sortedKeys.slice(startIndex, endIndex);

        // Update pagination UI
        updatePaginationUI(startIndex, endIndex, totalPages);

        console.log('üìÑ Pagination:', {
            currentPage,
            totalPages,
            pageSize,
            totalResults,
            showing: `${startIndex + 1}-${endIndex}`
        });

        // Display each group (only current page)
        console.log('üéØ Rendering rows:', {
            totalKeys: sortedKeys.length,
            pageKeys: pageKeys.length,
            pageKeysArray: pageKeys
        });

        pageKeys.forEach(key => {
            const group = resultsData[key];
            const row = document.createElement('tr');

            // Check if this is a running automation (no screenshots yet)
            const isRunning = group.status === 'running';

            // Count statuses
            const successCount = group.sites.filter(s => s.status === 'success').length;
            const errorCount = group.sites.filter(s => s.status === 'error').length;
            const runningCount = group.sites.filter(s => s.status === 'running').length;

            // Status summary
            let statusHtml = '';
            if (isRunning) {
                // Show running status for the whole automation
                statusHtml = `<div><span class="status-badge running">üîÑ ƒêang ch·∫°y...</span></div>`;
            } else {
                // Show detailed status after completion
                if (successCount > 0) statusHtml += `<span class="status-badge success">‚úÖ ${successCount}</span> `;
                if (errorCount > 0) statusHtml += `<span class="status-badge error">‚ùå ${errorCount}</span> `;
                if (runningCount > 0) statusHtml += `<span class="status-badge running">üîÑ ${runningCount}</span>`;
            }

            // Screenshots preview with count badge
            const screenshotCount = group.screenshots.length;
            let screenshotHtml = '<span style="color: #a0aec0;">Ch∆∞a c√≥</span>';
            if (isRunning) {
                screenshotHtml = '<span style="color: #f59e0b;">‚è≥ ƒêang ch·∫°y...</span>';
            } else if (screenshotCount > 0) {
                // Hi·ªÉn th·ªã n√∫t xem ·∫£nh, v√† ch·ªâ hi·ªÉn th·ªã n√∫t xem th√¥ng tin t√†i kho·∫£n n·∫øu c√≥
                const accountInfoBtn = group.hasAccountInfo ? `
                        <div class="screenshot-preview" onclick="openAccountInfoModal('${group.username}', '${key}')" title="Xem th√¥ng tin t√†i kho·∫£n">
                            <span class="screenshot-preview-icon">üìã</span>
                        </div>
                ` : '';

                screenshotHtml = `
                    <div style="display: flex; gap: 8px; align-items: center; justify-content: center;">
                        <div class="screenshot-preview" onclick="openScreenshotsModal('${key}')" title="Xem screenshots" style="position: relative;">
                            <span class="screenshot-preview-icon">üì∑</span>
                            <span style="position: absolute; top: -4px; right: -4px; background: linear-gradient(135deg, #ef4444, #dc2626); color: white; border-radius: 10px; padding: 2px 6px; font-size: 10px; font-weight: 700; min-width: 18px; text-align: center; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">${screenshotCount}</span>
                        </div>
                        ${accountInfoBtn}
                    </div>
                `;
            }

            // Format time
            const time = new Date(group.lastTimestamp).toLocaleString('vi-VN');

            // Run number = which run is this for this username (1st, 2nd, 3rd, ...)
            const runNumber = isRunning ? '-' : runNumberByKey[key];

            // Sites count
            const sitesCount = group.sites.length;

            // Check promo button
            const checkPromoBtn = isRunning
                ? '<span style="color: #a0aec0;">‚è≥ ƒêang ch·∫°y...</span>'
                : `<button class="btn btn-sm" onclick="checkPromoFromResult('${key}')" style="background: linear-gradient(135deg, #10b981, #059669); color: white; padding: 6px 12px; border-radius: 6px; border: none; cursor: pointer; font-size: 12px; font-weight: 600;">‚ñ∂Ô∏è START</button>`;

            row.innerHTML = `
                <td style="text-align: center;">
                    <input type="checkbox" class="row-checkbox" data-key="${key}" 
                           style="cursor: pointer; width: 18px; height: 18px;"
                           ${isRunning ? 'disabled' : ''}>
                </td>
                <td>${group.profileName || 'Unknown'}</td>
                <td><strong>${group.username}</strong></td>
                <td>${isRunning ? '<span style="color: #a0aec0;">-</span>' : `<span class="check-times-badge">L·∫ßn ${runNumber}</span>`}</td>
                <td>${statusHtml}</td>
                <td>${screenshotHtml}</td>
                <td>${time}</td>
                <td style="text-align: center;">${checkPromoBtn}</td>
            `;

            tbody.appendChild(row);
        });


    }

    // Open screenshots modal
    function openScreenshotsModal(key) {
        const group = resultsData[key];
        if (!group || group.screenshots.length === 0) return;

        const modal = document.getElementById('screenshotsModal');
        const title = document.getElementById('modalTitle');
        const grid = document.getElementById('modalScreenshotsGrid');

        // Set title
        title.textContent = `üì∑ K·∫øt Qu·∫£ - ${group.username} (${group.screenshots.length} trang)`;

        // Build screenshots grid - 3 columns layout with larger images
        let gridHTML = '<div class="screenshots-grid" style="display: grid !important; grid-template-columns: repeat(3, 1fr) !important; gap: 20px !important; padding: 20px !important; width: 100% !important; box-sizing: border-box !important;">';

        group.screenshots.forEach((screenshot, index) => {
            const time = new Date(screenshot.timestamp).toLocaleString('vi-VN');
            gridHTML += `
                <div class="screenshot-item" onclick="openFullScreenImage('${screenshot.url}', '${screenshot.site}')" style="width: auto !important; max-width: 100% !important; min-width: 0 !important; display: block !important; padding: 10px !important; text-align: center;">
                    <div class="screenshot-item-header" style="text-align: center; justify-content: center; flex-direction: column; gap: 5px;">
                        <span class="screenshot-site-name" style="font-size: 14px; font-weight: 700; color: #2d3748;">${screenshot.site}</span>
                        <span style="font-size: 11px; color: #718096; background: #f7fafc; padding: 2px 8px; border-radius: 10px; font-weight: 500;">#${index + 1}</span>
                    </div>
                    <img src="${screenshot.url}" 
                         alt="${screenshot.site}"
                         title="Click ƒë·ªÉ xem full size - ${screenshot.site}"
                         style="width: 100%; height: 250px; object-fit: cover; border-radius: 8px; border: 1px solid #e5e7eb;">
                    <div class="screenshot-item-footer" style="text-align: center; font-size: 11px; color: #718096; margin-top: 10px;">
                        ${time}
                    </div>
                </div>
                `;
        });

        gridHTML += '</div>';
        grid.innerHTML = gridHTML;

        console.log('üì∑ Screenshots modal opened:', {
            screenshotCount: group.screenshots.length,
            gridElement: grid.querySelector('.screenshots-grid'),
            gridStyle: grid.querySelector('.screenshots-grid')?.style.cssText
        });

        // Show modal
        modal.style.display = 'flex';
    }

    // Open full screen image
    function openFullScreenImage(imageUrl, siteName) {
        // Create full screen overlay
        const overlay = document.createElement('div');
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify - content: center;
            align - items: center;
            z - index: 10000;
            cursor: pointer;
            `;

        // Create image container
        const container = document.createElement('div');
        container.style.cssText = `
            position: relative;
            max - width: 90vw;
            max - height: 90vh;
            display: flex;
            flex - direction: column;
            align - items: center;
            `;

        // Create image
        const img = document.createElement('img');
        img.src = imageUrl;
        img.style.cssText = `
            max - width: 100 %;
            max - height: 85vh;
            object - fit: contain;
            border - radius: 8px;
            box - shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            `;

        // Create title
        const title = document.createElement('div');
        title.textContent = siteName;
        title.style.cssText = `
            color: white;
            font - size: 18px;
            font - weight: 600;
            margin - top: 15px;
            text - align: center;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border - radius: 20px;
            `;

        // Create close button
        const closeBtn = document.createElement('button');
        closeBtn.innerHTML = '√ó';
        closeBtn.style.cssText = `
            position: absolute;
            top: -40px;
            right: -40px;
            width: 40px;
            height: 40px;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font - size: 24px;
            border - radius: 50 %;
            cursor: pointer;
            display: flex;
            align - items: center;
            justify - content: center;
            transition: background 0.2s;
            `;

        closeBtn.onmouseover = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.3)';
        closeBtn.onmouseout = () => closeBtn.style.background = 'rgba(255, 255, 255, 0.2)';

        // Assemble elements
        container.appendChild(img);
        container.appendChild(title);
        container.appendChild(closeBtn);
        overlay.appendChild(container);

        // Add to body
        document.body.appendChild(overlay);

        // Close handlers
        const closeFullScreen = () => {
            document.body.removeChild(overlay);
        };

        overlay.addEventListener('click', (e) => {
            if (e.target === overlay) closeFullScreen();
        });

        closeBtn.addEventListener('click', closeFullScreen);

        // ESC key handler
        const escHandler = (e) => {
            if (e.key === 'Escape') {
                closeFullScreen();
                document.removeEventListener('keydown', escHandler);
            }
        };
        document.addEventListener('keydown', escHandler);
    }

    // Close screenshots modal
    function closeScreenshotsModal() {
        const modal = document.getElementById('screenshotsModal');
        modal.style.display = 'none';
    }

    // Open account info modal
    async function openAccountInfoModal(username, sessionKey) {
        const modal = document.getElementById('accountInfoModal');
        const title = document.getElementById('accountInfoTitle');
        const content = document.getElementById('accountInfoContent');

        title.textContent = `üìã Th√¥ng Tin T√†i Kho·∫£n - ${username} `;
        content.innerHTML = '<div style="text-align: center; padding: 40px;"><span style="font-size: 24px;">‚è≥</span><br>ƒêang t·∫£i...</div>';
        modal.style.display = 'flex';

        try {
            // Get session info to find sites
            const group = resultsData[sessionKey];
            if (!group || !group.sites || group.sites.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 40px; color: #f59e0b;">‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y th√¥ng tin sites</div>';
                return;
            }

            // Fetch account info from the first site only (since all sites use same account)
            const firstSite = group.sites[0];
            const siteName = firstSite.name;

            try {
                console.log('üîç Fetching account info:', { username, url: `/api/accounts/nohu/${username}` });
                const response = await fetch(`/api/accounts/nohu/${username}`);
                console.log('üì° Response status:', response.status, response.statusText);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('üìã Account data:', data);

                if (data.success && data.account) {
                    const acc = data.account;
                    const sitesCount = group.sites.length;

                    content.innerHTML = `
                        <div style="background: #f7fafc; border-radius: 12px; padding: 20px; border: 1px solid #e2e8f0;">
                            <h4 style="margin: 0 0 15px 0; color: #2d3748; display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 20px;">üë§</span> Th√¥ng Tin T√†i Kho·∫£n Chung
                                <span style="background: #e2e8f0; color: #4a5568; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 600;">
                                    ${sitesCount} sites
                                </span>
                            </h4>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; font-size: 14px;">
                                <div>
                                    <strong style="color: #4a5568;">üë§ T√™n ƒëƒÉng nh·∫≠p:</strong><br>
                                    <span style="color: #2d3748; font-family: monospace; background: #f1f5f9; padding: 4px 8px; border-radius: 4px;">${acc.username}</span>
                                </div>
                                <div>
                                    <strong style="color: #4a5568;">üîë M·∫≠t kh·∫©u:</strong><br>
                                    <span style="color: #2d3748; font-family: monospace; background: #f1f5f9; padding: 4px 8px; border-radius: 4px;">${acc.password}</span>
                                </div>
                                <div>
                                    <strong style="color: #4a5568;">üí∞ MK r√∫t ti·ªÅn:</strong><br>
                                    <span style="color: #2d3748; font-family: monospace; background: #f1f5f9; padding: 4px 8px; border-radius: 4px;">${acc.withdrawPassword || 'N/A'}</span>
                                </div>
                                <div>
                                    <strong style="color: #4a5568;">üìù H·ªç v√† t√™n:</strong><br>
                                    <span style="color: #2d3748;">${acc.fullname || 'N/A'}</span>
                                </div>
                                <div>
                                    <strong style="color: #4a5568;">üè¶ Ng√¢n h√†ng:</strong><br>
                                    <span style="color: #2d3748;">${acc.bank?.name || 'N/A'}</span>
                                </div>
                                <div>
                                    <strong style="color: #4a5568;">üè¢ Chi nh√°nh:</strong><br>
                                    <span style="color: #2d3748;">${acc.bank?.branch || 'N/A'}</span>
                                </div>
                                <div style="grid-column: 1 / -1;">
                                    <strong style="color: #4a5568;">üí≥ S·ªë t√†i kho·∫£n:</strong><br>
                                    <span style="color: #2d3748; font-family: monospace; background: #f1f5f9; padding: 4px 8px; border-radius: 4px;">${acc.bank?.accountNumber || 'N/A'}</span>
                                </div>
                                <div style="grid-column: 1 / -1;">
                                    <strong style="color: #4a5568;">üìÖ Ng√†y ƒëƒÉng k√Ω:</strong><br>
                                    <span style="color: #718096;">${new Date(acc.registeredAt).toLocaleString('vi-VN')}</span>
                                </div>
                                <div style="grid-column: 1 / -1;">
                                    <strong style="color: #4a5568;">üì± C√°c trang ƒë∆∞·ª£c ƒëƒÉng k√Ω:</strong><br>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;">
                                        ${acc.sites && acc.sites.length > 0
                            ? acc.sites.map(site => `
                                                <span style="background: linear-gradient(135deg, #667eea, #764ba2); color: white; padding: 6px 12px; border-radius: 20px; font-size: 12px; font-weight: 600;">
                                                    ${site}
                                                </span>
                                            `).join('')
                            : '<span style="color: #718096; font-style: italic;">Kh√¥ng c√≥ th√¥ng tin</span>'
                        }
                                    </div>
                                </div>
                            </div>
                            <div style="margin-top: 15px; padding: 12px; background: #e6fffa; border-radius: 8px; border-left: 4px solid #38b2ac;">
                                <p style="margin: 0; color: #234e52; font-size: 13px;">
                                    <strong>‚ÑπÔ∏è L∆∞u √Ω:</strong> Th√¥ng tin n√†y ƒë∆∞·ª£c s·ª≠ d·ª•ng chung cho t·∫•t c·∫£ ${sitesCount} trang web trong session n√†y.
                                </p>
                            </div>
                        </div>
                    `;
                } else {
                    content.innerHTML = `
                        <div style="background: #fff5f5; border-radius: 12px; padding: 20px; border: 1px solid #feb2b2;">
                            <h4 style="margin: 0; color: #c53030;">‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y th√¥ng tin</h4>
                            <p style="margin: 10px 0 0 0; color: #742a2a;">Kh√¥ng t√¨m th·∫•y th√¥ng tin t√†i kho·∫£n cho session n√†y</p>
                        </div>
                    `;
                }
            } catch (err) {
                console.error(`‚ùå Error loading account for ${siteName}:`, err);
                const errorMsg = err.message || 'Unknown error';
                content.innerHTML = `
                    <div style="background: #fff5f5; border-radius: 12px; padding: 20px; border: 1px solid #feb2b2;">
                        <h4 style="margin: 0; color: #c53030;">‚ùå L·ªói t·∫£i th√¥ng tin t√†i kho·∫£n</h4>
                        <p style="margin: 10px 0 0 0; color: #742a2a; font-size: 13px;">
                            <strong>Chi ti·∫øt:</strong> ${errorMsg}<br>
                            <strong>Site:</strong> ${siteName}<br>
                            <strong>Username:</strong> ${username}
                        </p>
                        <div style="margin-top: 15px; padding: 10px; background: #f7fafc; border-radius: 6px; font-size: 12px; color: #4a5568;">
                            üí° <strong>C√≥ th·ªÉ do:</strong><br>
                            ‚Ä¢ API endpoint ch∆∞a ƒë∆∞·ª£c thi·∫øt l·∫≠p<br>
                            ‚Ä¢ T√†i kho·∫£n ch∆∞a ƒë∆∞·ª£c l∆∞u trong database<br>
                            ‚Ä¢ L·ªói k·∫øt n·ªëi m·∫°ng
                        </div>
                    </div>
                `;
            }

        } catch (error) {
            console.error('Error loading account info:', error);
            content.innerHTML = '<div style="text-align: center; padding: 40px; color: #e53e3e;">‚ùå L·ªói t·∫£i th√¥ng tin</div>';
        }
    }

    // Check promo from result row - open form modal with pre-filled data
    async function checkPromoFromResult(key) {
        const group = resultsData[key];
        if (!group) {
            showToast('error', 'L·ªói', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin k·∫øt qu·∫£');
            return;
        }

        // Check if already running
        if (group.status === 'running') {
            showToast('warning', 'ƒêang ch·∫°y', 'Automation n√†y ƒëang ch·∫°y, vui l√≤ng ƒë·ª£i');
            return;
        }

        const username = group.username;
        const sites = group.sites;

        if (!username || !sites || sites.length === 0) {
            showToast('error', 'Thi·∫øu th√¥ng tin', 'Kh√¥ng t√¨m th·∫•y th√¥ng tin t√†i kho·∫£n ho·∫∑c trang');
            return;
        }

        // Load metadata to get profileId and site info
        let profileId = null;
        let siteNames = [];

        if (group.sessionId) {
            try {
                const metadataUrl = `/screenshots/${username}/${group.sessionId}/metadata.json`;
                const metadataResponse = await fetch(metadataUrl);

                if (metadataResponse.ok) {
                    const metadata = await metadataResponse.json();

                    // Get profileId from metadata
                    if (metadata && metadata.profileId) {
                        profileId = metadata.profileId;
                        console.log('‚úÖ Found profileId from metadata:', profileId);
                    }

                    // Get site names from metadata
                    if (metadata && metadata.sites && Array.isArray(metadata.sites)) {
                        siteNames = metadata.sites.map(s => s.name);
                    }
                }
            } catch (err) {
                console.warn('‚ö†Ô∏è Could not load metadata:', err);
            }
        }

        // Fallback: get site names from results
        if (siteNames.length === 0) {
            siteNames = sites.map(s => s.name);
        }

        // Get profile info
        const profileResult = await profileManager.loadAll();
        if (!profileResult.success || !profileResult.profiles || profileResult.profiles.length === 0) {
            showToast('error', 'Kh√¥ng c√≥ profile', 'Vui l√≤ng t·∫°o profile tr∆∞·ªõc');
            return;
        }

        // Find target profile
        let targetProfile = null;
        if (profileId) {
            targetProfile = profileResult.profiles.find(p => p.uuid === profileId);
        }
        if (!targetProfile) {
            targetProfile = profileResult.profiles.find(p => p.name === group.profileName);
        }
        if (!targetProfile) {
            targetProfile = profileResult.profiles[0];
        }

        console.log('üéØ Opening form with:', {
            username,
            profileId: targetProfile.uuid,
            profileName: targetProfile.name,
            sites: siteNames
        });

        // Select the profile
        profileManager.select(targetProfile.uuid);
        await loadProfilesCarousel();

        // Open form modal and switch to Check Promo tab
        openFormModal();
        switchModalTab('promo');

        // Wait a bit for UI to render
        await new Promise(resolve => setTimeout(resolve, 100));

        // Fill username
        const usernameInput = document.getElementById('promoUsername');
        if (usernameInput) {
            usernameInput.value = username;
        }

        // Auto-select matching sites (App Promo only, not SMS)
        const appCheckboxes = document.querySelectorAll('#appPromoSites .site-check');
        let checkedCount = 0;

        appCheckboxes.forEach(checkbox => {
            const siteName = checkbox.getAttribute('data-name');
            if (!siteName) return;

            // Check if this site is in the results
            const shouldCheck = siteNames.some(name => {
                const nameClean = name.toLowerCase().trim();
                const siteNameClean = siteName.toLowerCase().trim();

                return nameClean === siteNameClean ||
                    siteNameClean.includes(nameClean) ||
                    nameClean.includes(siteNameClean);
            });

            if (shouldCheck) {
                checkbox.checked = true;
                checkedCount++;
                console.log(`‚úÖ Auto-checked: ${siteName}`);
            } else {
                checkbox.checked = false;
            }
        });

        console.log(`üìä Auto-selected ${checkedCount} sites from results:`, siteNames);
        showToast('info', 'Form ƒë√£ ƒëi·ªÅn s·∫µn', `Username: ${username}, Profile: ${targetProfile.name}, ${checkedCount} trang ƒë√£ ch·ªçn`);
    }



    // Close account info modal
    function closeAccountInfoModal() {
        const modal = document.getElementById('accountInfoModal');
        modal.style.display = 'none';
    }

    // Close modal on ESC key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            closeScreenshotsModal();
            closeAccountInfoModal();
        }
    });

    // Toggle select all checkboxes
    function toggleSelectAll(checkbox) {
        const checkboxes = document.querySelectorAll('.row-checkbox');
        checkboxes.forEach(cb => {
            cb.checked = checkbox.checked;
        });
    }

    // Delete selected results
    async function deleteSelectedResults() {
        const checkboxes = document.querySelectorAll('.row-checkbox:checked');

        if (checkboxes.length === 0) {
            showToast('warning', 'Ch∆∞a ch·ªçn', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 k·∫øt qu·∫£ ƒë·ªÉ x√≥a');
            return;
        }

        if (!confirm(`B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${checkboxes.length} k·∫øt qu·∫£ ƒë√£ ch·ªçn?`)) {
            return;
        }

        try {
            // Get selected keys (username-sessionId pairs)
            const selectedKeys = Array.from(checkboxes).map(cb => cb.dataset.key);

            // Build list of sessions to delete (username + sessionId)
            const sessionsToDelete = selectedKeys.map(key => {
                const data = resultsData[key];
                return {
                    username: data?.username,
                    sessionId: data?.sessionId || null // null for old structure (no session)
                };
            }).filter(s => s.username);

            console.log('üóëÔ∏è Deleting sessions:', sessionsToDelete);

            // Call API to delete specific sessions
            const response = await fetch('/api/results/clear-selected', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ sessions: sessionsToDelete })
            });

            const data = await response.json();

            if (!data.success) {
                throw new Error(data.error || 'Failed to delete selected results');
            }

            // Store current page to restore after deletion
            const currentPageBeforeDelete = currentPage;

            // Remove from in-memory data
            selectedKeys.forEach(key => {
                delete resultsData[key];
            });

            // Smart refresh after deletion
            await refreshResultsIfNeeded();

            // Restore current page (or adjust if out of range)
            const totalPages = Math.ceil(Object.keys(resultsData).length / pageSize);
            if (currentPageBeforeDelete <= totalPages && totalPages > 0) {
                currentPage = currentPageBeforeDelete;
            } else if (totalPages > 0) {
                currentPage = totalPages; // Go to last page if current page is out of range
            } else {
                currentPage = 1; // Default to page 1 if no results
            }

            // Refresh table display with preserved page
            refreshResultsTable();

            // Uncheck "select all"
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (selectAllCheckbox) selectAllCheckbox.checked = false;

            // Show detailed message: X results and Y screenshots
            const deletedSessions = sessionsToDelete.length;
            const deletedFiles = data.deletedFiles || 0;
            showToast('success', 'ƒê√£ x√≥a', `ƒê√£ x√≥a ${deletedSessions} k·∫øt qu·∫£ v√† ${deletedFiles} ·∫£nh`);
        } catch (error) {
            console.error('Error deleting selected results:', error);
            showToast('error', 'L·ªói', 'Kh√¥ng th·ªÉ x√≥a k·∫øt qu·∫£: ' + error.message);
        }
    }

    // Delete all results (alias for clearResultsTable)
    async function deleteAllResults() {
        return clearResultsTable();
    }

    // Clear all results
    async function clearResultsTable() {
        if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a T·∫§T C·∫¢ k·∫øt qu·∫£?')) {
            return;
        }

        showToast('info', 'ƒêang x√≥a...', 'ƒêang x√≥a t·∫•t c·∫£ k·∫øt qu·∫£...');

        try {
            // Call API to delete all screenshots
            // Use relative URL to automatically use current port
            const response = await fetch('/api/results/clear', {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json' }
            });

            const data = await response.json();

            if (!data.success) {
                throw new Error(data.error || 'Failed to clear results');
            }

            // Clear in-memory data
            Object.keys(resultsData).forEach(key => delete resultsData[key]);

            // Clear processed results tracking
            processedResults.clear();

            // Reset to page 1 since all results are deleted
            currentPage = 1;

            // Smart refresh after deletion
            await refreshResultsIfNeeded();

            // Refresh table display
            refreshResultsTable();

            showToast('success', 'ƒê√£ x√≥a', `ƒê√£ x√≥a ${data.deletedFiles || 0} file k·∫øt qu·∫£`);
        } catch (error) {
            console.error('Error clearing results:', error);
            showToast('error', 'L·ªói', 'Kh√¥ng th·ªÉ x√≥a k·∫øt qu·∫£: ' + error.message);
        }
    }

    // Example: Add result when automation completes
    // This should be called from automation callbacks
    window.addAutomationResult = function (profileName, username, siteName, status, screenshot) {
        addResultToTable({
            profileName: profileName,
            username: username,
            siteName: siteName,
            status: status,
            screenshot: screenshot,
            timestamp: Date.now()
        });
    };

    // Removed loadSavedResults() - now we only load from server (actual files)
    // This ensures results are always accurate and match actual screenshot files

    // Load automation statuses (running automations)
    async function loadAutomationStatuses() {
        try {
            const response = await fetch('/api/automation/statuses');
            const data = await response.json();

            if (data.success && data.statuses) {
                // Track which usernames are currently running
                const currentlyRunning = new Set();

                // Add running statuses to table
                let needsCarouselRefresh = false;
                data.statuses.forEach(status => {
                    if (status.message) {
                        console.log(`üì° Received status with message: "${status.message}" for ${status.username}`);
                    }
                    if (status.status === 'running') {
                        currentlyRunning.add(status.username);

                        // Mark profile as running if not already marked
                        if (typeof profileManager !== 'undefined') {
                            let profile = null;
                            if (status.profileId) {
                                profile = allProfilesData.find(p => p.uuid === status.profileId);
                            }
                            if (!profile) {
                                profile = allProfilesData.find(p => p.name === status.username);
                            }

                            if (profile && !profileManager.runningProfiles.has(profile.uuid)) {
                                profileManager.runningProfiles.add(profile.uuid);
                                profileManager.runningStartTimes = profileManager.runningStartTimes || new Map();
                                profileManager.runningStartTimes.set(profile.uuid, Date.now());
                                profileManager.saveRunningProfiles();
                                needsCarouselRefresh = true;
                                console.log(`‚úÖ Marked profile as running: ${profile.name}`);
                            }
                        }

                        // Re-enable button when server confirms start
                        const btnRunAction = document.getElementById('btnRunAction');
                        if (btnRunAction && btnRunAction.disabled) {
                            btnRunAction.disabled = false;
                            btnRunAction.style.opacity = '1';
                            btnRunAction.style.cursor = 'pointer';
                            console.log('‚úÖ Button re-enabled after server confirmed start');
                        }

                        // Add as running result
                        const sessionId = status.sessionId || 'running'; // Use 'running' as temp sessionId
                        const key = `${status.username}_${sessionId}`;

                        if (!resultsData[key]) {
                            resultsData[key] = {
                                profileName: status.profileName || 'Profile',
                                username: status.username,
                                sessionId: sessionId, // Store sessionId
                                sites: status.sites || [],
                                screenshots: [],
                                checkTimes: [],
                                status: 'running',
                                message: status.message || '',
                                firstTimestamp: status.timestamp || Date.now(),
                                lastTimestamp: status.timestamp || Date.now()
                            };

                            refreshResultsTable();
                        } else {
                            // Update message for existing running entry
                            // Always update if message exists (even if empty string)
                            if ('message' in status) {
                                console.log(`üìä Before update - resultsData[${key}].message = "${resultsData[key].message}"`);
                                resultsData[key].message = status.message || '';
                                resultsData[key].status = 'running'; // Ensure status is marked as running
                                resultsData[key].lastTimestamp = status.timestamp || Date.now();
                                console.log(`üìä After update - resultsData[${key}].message = "${resultsData[key].message}"`);
                                console.log(`üìä Calling refreshResultsTable() for key: ${key}`);
                                refreshResultsTable();
                                console.log(`üìä Updated running entry message: "${status.message}"`);
                            } else {
                                console.log(`‚ö†Ô∏è Status has no message property for key: ${key}`);
                            }
                        }
                    } else if (status.status === 'completed' || status.status === 'error') {
                        // Remove running entry when completed/error
                        const sessionId = status.sessionId || 'running';
                        const key = `${status.username}_${sessionId}`;

                        if (resultsData[key] && resultsData[key].status === 'running') {
                            delete resultsData[key];
                            console.log(`üóëÔ∏è Removed running entry for completed automation: ${key}`);
                            refreshResultsTable();
                        }

                        // Clear running flag for profile when automation completes/errors
                        if (typeof profileManager !== 'undefined') {
                            // Try to find profile by profileId first (most accurate)
                            let profile = null;
                            if (status.profileId) {
                                profile = profileManager.profiles.find(p => p.uuid === status.profileId);
                            }
                            // Fallback: find by username
                            if (!profile) {
                                profile = profileManager.profiles.find(p => p.name === status.username);
                            }

                            if (profile && profileManager.runningProfiles.has(profile.uuid)) {
                                profileManager.runningProfiles.delete(profile.uuid);
                                console.log(`‚úÖ Cleared running flag for profile: ${profile.name} (status: ${status.status})`);

                                // Cleanup start time tracking
                                if (profileManager.runningStartTimes) {
                                    profileManager.runningStartTimes.delete(profile.uuid);
                                }

                                profileManager.saveRunningProfiles();
                                console.log(`‚úÖ Cleared running flag for profile: ${profile.name} (automation ${status.status})`);

                                // Refresh carousel to update UI
                                if (typeof loadProfilesCarousel === 'function') {
                                    loadProfilesCarousel();
                                }
                            }
                        }
                    }
                });

                // Sync profileManager.runningProfiles with server state (with delay to avoid race conditions)
                // Only remove profiles that have been NOT running for a while
                const profilesToRemove = [];
                for (const profileId of profileManager.runningProfiles) {
                    const profile = allProfilesData.find(p => p.uuid === profileId);
                    if (profile && !currentlyRunning.has(profile.name)) {
                        // Check if this profile has been marked as running recently (within 30 seconds)
                        const runningStartTime = profileManager.runningStartTimes?.get(profileId) || 0;
                        const timeSinceStart = Date.now() - runningStartTime;

                        // Only remove if it's been more than 30 seconds since marked as running
                        // This prevents race conditions where server hasn't updated status yet
                        if (timeSinceStart > 30000) {
                            profilesToRemove.push(profileId);
                        } else {
                            console.log(`‚è≥ Profile ${profile.name} not in server running list, but recently started (${Math.round(timeSinceStart / 1000)}s ago) - keeping running flag`);
                        }
                    }
                }

                if (profilesToRemove.length > 0) {
                    profilesToRemove.forEach(profileId => {
                        profileManager.runningProfiles.delete(profileId);
                        if (profileManager.runningStartTimes) {
                            profileManager.runningStartTimes.delete(profileId);
                        }
                        console.log(`‚úÖ Synced: Removed running flag for profile ${profileId} (not running on server for >30s)`);
                    });
                    profileManager.saveRunningProfiles();
                    needsCarouselRefresh = true;
                }

                // Refresh carousel if any changes detected
                if (needsCarouselRefresh && typeof loadProfilesCarousel === 'function') {
                    await loadProfilesCarousel();
                }
            }
        } catch (error) {
            console.error('Failed to load automation statuses:', error);
        }
    }

    // Load results from server API (scan screenshots folder)
    async function loadResultsFromServer() {
        try {
            // Use relative URL with tool filter to only get NOHU tool results
            const response = await fetch('/api/automation/results?tool=nohu-tool');
            const data = await response.json();

            if (data.success && data.results) {
                // Track which profiles have completed results
                const profilesWithResults = new Set();

                // Store current pagination state before clearing
                const previousCurrentPage = currentPage;
                const previousTotalResults = totalResults;

                // Clear processed results tracking to allow re-processing
                processedResults.clear();

                // Clear and rebuild resultsData from server
                Object.keys(resultsData).forEach(key => delete resultsData[key]);

                // Set flag to indicate this is an auto-refresh
                window.isAutoRefreshInProgress = true;

                // Add all results and track profiles
                data.results.forEach(result => {
                    addResultToTable(result);

                    // Track profile that has results (completed automation)
                    if (result.profileName) {
                        profilesWithResults.add(result.profileName);
                    }
                });

                // Check if there are any running automations on server
                try {
                    const statusResponse = await fetch('/api/automation/statuses');
                    const statusData = await statusResponse.json();

                    if (statusData.success && statusData.statuses) {
                        // Get list of running usernames from server
                        const runningUsernames = new Set(
                            statusData.statuses
                                .filter(s => s.status === 'running')
                                .map(s => s.username)
                        );

                        // Remove running entries that are no longer running on server
                        Object.keys(resultsData).forEach(key => {
                            const entry = resultsData[key];
                            if (entry.status === 'running' && !runningUsernames.has(entry.username)) {
                                console.log(`üóëÔ∏è Removing stale running entry: ${key} (not running on server)`);
                                delete resultsData[key];
                            }
                        });
                    }
                } catch (err) {
                    console.error('‚ö†Ô∏è Failed to check running statuses:', err);
                }

                // Clear the auto-refresh flag
                window.isAutoRefreshInProgress = false;

                // Auto-clear running status - DISABLED (now using server status "completed")
                // This old logic was clearing too early based on screenshot count
                /*
                if (profilesWithResults.size > 0 && typeof profileManager !== 'undefined') {
                    let clearedCount = 0;
 
                    // Get all running profiles
                    const runningProfiles = Array.from(profileManager.runningProfiles);
 
                    // Check each running profile
                    for (const profileId of runningProfiles) {
                        const profile = profileManager.profiles.find(p => p.uuid === profileId);
 
                        if (!profile || !profilesWithResults.has(profile.name)) continue;
 
                        // Count screenshots for this profile's latest session
                        const profileResults = data.results.filter(r => r.profileName === profile.name);
 
                        // Group by session
                        const sessionGroups = {};
                        profileResults.forEach(r => {
                            const sid = r.sessionId || 'default';
                            if (!sessionGroups[sid]) sessionGroups[sid] = [];
                            sessionGroups[sid].push(r);
                        });
 
                        // Get latest session
                        const latestSession = Object.entries(sessionGroups)
                            .sort((a, b) => {
                                const aTime = Math.max(...a[1].map(r => r.timestamp));
                                const bTime = Math.max(...b[1].map(r => r.timestamp));
                                return bTime - aTime;
                            })[0];
 
                        if (!latestSession) continue;
 
                        const screenshotCount = latestSession[1].length;
                        const lastScreenshotTime = Math.max(...latestSession[1].map(s => s.timestamp));
                        const timeSinceLastScreenshot = Date.now() - lastScreenshotTime;
 
                        // Heuristic: Consider completed if:
                        // - Has 5+ screenshots (most sites) AND no new screenshots for 30s
                        // OR has 7 screenshots (all sites)
                        const isStale = timeSinceLastScreenshot > 30000;
                        const isCompleted = screenshotCount >= 7 || (screenshotCount >= 5 && isStale);
 
                        if (isCompleted) {
                            profileManager.runningProfiles.delete(profileId);
                            clearedCount++;
                            console.log(`‚úÖ Auto-cleared: ${profile.name} (${screenshotCount} screenshots, ${Math.round(timeSinceLastScreenshot / 1000)}s ago)`);
                        } else {
                            console.log(`‚è≥ Still running: ${profile.name} (${screenshotCount} screenshots, ${Math.round(timeSinceLastScreenshot / 1000)}s ago)`);
                        }
                    }
                    // Save if any profiles were cleared
                    if (clearedCount > 0) {
                        profileManager.saveRunningProfiles();
                        console.log(`üîÑ Auto-cleared ${clearedCount} completed profiles`);
 
                        // Reload profile carousel to update UI
                        if (typeof loadProfilesCarousel === 'function') {
                            await loadProfilesCarousel();
                        }
                    }
                }
                */

                console.log(`‚úÖ Loaded ${data.results.length} results from screenshots folder`);

                // Refresh table display
                refreshResultsTable();
            }
        } catch (error) {
            console.error('Failed to load results from server:', error);
        } finally {
            // Always clear the auto-refresh flag
            window.isAutoRefreshInProgress = false;
        }
    }

    // Refresh button handler
    window.refreshResults = function () {
        // Clear auto-refresh flag for manual refresh
        window.isAutoRefreshInProgress = false;
        loadResultsFromServer();
        showToast('success', 'ƒê√£ t·∫£i l·∫°i', 'K·∫øt qu·∫£ ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t');
    };

    // Smart refresh - only when needed
    window.refreshResultsIfNeeded = function () {
        // This will be called after automation completes or files are deleted
        window.isAutoRefreshInProgress = false; // Treat as manual refresh
        loadResultsFromServer();
        console.log('üîÑ Smart refresh triggered');
    };

    // Listen for automation completion to trigger refresh
    // Only refresh when ALL sites are completed (status = 'completed'), not when individual sites complete
    let lastCompletedCheck = 0;
    let lastCompletedTimestamp = 0;
    function checkForAutomationCompletion() {
        const now = Date.now();

        // Only check if we have running automations and it's been a while
        if (typeof profileManager !== 'undefined' &&
            profileManager.runningProfiles &&
            profileManager.runningProfiles.size > 0 &&
            now - lastCompletedCheck > 30000) { // Check every 30 seconds

            lastCompletedCheck = now;

            // Check if automation completed (all sites done)
            fetch('/api/automation/statuses')
                .then(response => response.json())
                .then(data => {
                    if (data.success && data.statuses) {
                        // Only refresh if status is 'completed' (all sites done)
                        // Don't refresh for individual site completions
                        const completedStatus = Object.values(data.statuses).find(status =>
                            status.status === 'completed' &&
                            status.timestamp > lastCompletedTimestamp // New completion
                        );

                        if (completedStatus) {
                            lastCompletedTimestamp = completedStatus.timestamp;
                            console.log('üéØ All sites completed, refreshing results...');
                            refreshResultsIfNeeded();
                        }
                    }
                })
                .catch(error => console.error('Error checking automation status:', error));
        }
    }

    // Auto-refresh DISABLED - only refresh on user action or specific events
    // This prevents pagination jumping issues
    // Manual refresh available via "T·∫£i L·∫°i" button

    // Check for running automation status updates (more frequent for better UX)
    setInterval(() => {
        loadAutomationStatuses(); // Check running status
        checkForAutomationCompletion(); // Check if automation completed
    }, 5000); // Check every 5 seconds for faster updates

    // Auto-refresh results table when automation is running
    let lastResultsRefresh = 0;
    setInterval(() => {
        const now = Date.now();
        // Only refresh if there are running profiles and it's been at least 5 seconds since last refresh
        if (typeof profileManager !== 'undefined' &&
            profileManager.runningProfiles &&
            profileManager.runningProfiles.size > 0 &&
            now - lastResultsRefresh > 5000) {
            lastResultsRefresh = now;
            console.log('üîÑ Auto-refreshing results table (automation running)...');
            loadResultsFromServer();
        }
    }, 5000); // Check every 5 seconds

    // Recalculate page size when window is resized
    let resizeTimeout;
    window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            console.log('üîÑ Window resized, recalculating page size...');
            refreshResultsTable();
        }, 300); // Debounce 300ms
    });

    // ============================================
    // PAGINATION FUNCTIONS
    // ============================================

    function updatePaginationUI(startIndex, endIndex, totalPages) {
        const paginationControls = document.getElementById('paginationControls');

        if (totalResults === 0) {
            paginationControls.style.display = 'none';
            return;
        }

        paginationControls.style.display = 'flex';

        // Update info
        document.getElementById('pageStart').textContent = startIndex + 1;
        document.getElementById('pageEnd').textContent = endIndex;
        document.getElementById('totalResults').textContent = totalResults;
        document.getElementById('currentPage').textContent = currentPage;
        document.getElementById('totalPages').textContent = totalPages;

        // Update buttons state
        document.getElementById('btnFirst').disabled = currentPage === 1;
        document.getElementById('btnPrev').disabled = currentPage === 1;
        document.getElementById('btnNext').disabled = currentPage === totalPages;
        document.getElementById('btnLast').disabled = currentPage === totalPages;
    }

    window.goToFirstPage = function () {
        currentPage = 1;
        refreshResultsTable();
    };

    window.goToPrevPage = function () {
        if (currentPage > 1) {
            currentPage--;
            refreshResultsTable();
        }
    };

    window.goToNextPage = function () {
        const totalPages = Math.ceil(totalResults / pageSize);
        if (currentPage < totalPages) {
            currentPage++;
            refreshResultsTable();
        }
    };

    window.goToLastPage = function () {
        const totalPages = Math.ceil(totalResults / pageSize);
        currentPage = totalPages;
        refreshResultsTable();
    };

    window.changePageSize = function () {
        // No longer needed - page size is calculated automatically
        // Keep function for backward compatibility
        refreshResultsTable();
    };

    // ============================================
    // MODAL FUNCTIONS FOR V2 DESIGN
    // ============================================

    // Modal state
    let currentModalTab = 'auto';

    // Open Form Modal
    window.openFormModal = function () {
        const modal = document.getElementById('formModal');
        if (modal) {
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }
    };

    // Close Form Modal
    window.closeFormModal = function () {
        const modal = document.getElementById('formModal');
        if (modal) {
            modal.classList.remove('active');
            document.body.style.overflow = '';
        }
    };

    // Confirm and run check promo from modal
    async function confirmCheckPromo() {
        // Get selected sites from modal
        const selectedSites = [];
        const checkboxes = document.querySelectorAll('#selectSitesModal .site-check:checked');

        checkboxes.forEach(checkbox => {
            const name = checkbox.getAttribute('data-name');
            // CENTRALIZED CONFIG: Ch·ªâ pass name, URL s·∫Ω ƒë∆∞·ª£c l·∫•y t·ª´ optimized-automation.js
            if (name) {
                selectedSites.push({ name });
            }
        });

        if (selectedSites.length === 0) {
            showToast('warning', 'Ch∆∞a ch·ªçn trang', 'Vui l√≤ng ch·ªçn √≠t nh·∫•t 1 trang ƒë·ªÉ check khuy·∫øn m√£i');
            return;
        }

        // Close modal
        closeSelectSitesModal();

        // Check if profile selected
        if (!profileManager.selectedProfileId) {
            showToast('warning', 'Ch∆∞a ch·ªçn profile', 'Vui l√≤ng ch·ªçn profile t·ª´ sidebar');
            return;
        }

        // IMPORTANT: Check if profile already running (prevent duplicate runs)
        if (profileManager.isRunning(profileManager.selectedProfileId)) {
            showToast('warning', 'Profile ƒëang ch·∫°y', 'Profile n√†y ƒëang ch·∫°y automation, vui l√≤ng ch·ªçn profile kh√°c');
            return;
        }

        // Validate API key
        const apiKey = apiKeyManager.get();
        if (!apiKey || apiKey.trim() === '') {
            showToast('error', 'Thi·∫øu API Key', '‚ö†Ô∏è Vui l√≤ng th√™m Captcha API Key ·ªü sidebar b√™n tr√°i tr∆∞·ªõc khi ch·∫°y automation!\n\nüìù L·∫•y API key t·∫°i: autocaptcha.pro', 8000);
            return;
        }

        // Run check promo automation (will disable button via runAutomationWithMarking)
        await runAutomationWithMarking('nohu-tool', 'checkPromoOnly', {
            username: 'checkpromo_' + Date.now(),
            apiKey: apiKey,
            checkPromo: true,
            sites: selectedSites
        });
    }


    // Switch Modal Tab
    window.switchModalTab = function (tabName) {
        currentModalTab = tabName;

        // Update tab active state
        document.querySelectorAll('.modal-tab').forEach(tab => {
            tab.classList.remove('active');
        });
        const activeTab = document.querySelector(`.modal-tab[data-tab="${tabName}"]`);
        if (activeTab) activeTab.classList.add('active');

        // Update tab content
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
        });
        const content = document.getElementById(`tab-${tabName}`);
        if (content) {
            content.classList.add('active');
        }

        // Show/hide promo type selector and sites based on tab
        const promoTypeSelector = document.getElementById('promoTypeSelector');
        const appGroup = document.getElementById('appPromoGroup');
        const smsGroup = document.getElementById('smsPromoGroup');

        if (tabName === 'auto') {
            // Auto tab: Show selector, allow toggle between app/sms
            if (promoTypeSelector) promoTypeSelector.style.display = 'block';
            // Keep current selection
            togglePromoSites();
        } else {
            // Other tabs: Hide selector, always show app sites only
            if (promoTypeSelector) promoTypeSelector.style.display = 'none';
            if (appGroup) appGroup.style.display = 'block';
            if (smsGroup) smsGroup.style.display = 'none';
        }
    };

    // Close modal on ESC key
    document.addEventListener('keydown', function (e) {
        if (e.key === 'Escape') {
            closeFormModal();
        }
    });

    // Close modal on background click
    document.addEventListener('DOMContentLoaded', function () {
        const modal = document.getElementById('formModal');
        if (modal) {
            modal.addEventListener('click', function (e) {
                if (e.target === this) {
                    closeFormModal();
                }
            });
        }
    });

    // ============================================
    // AUTO-REFRESH FUNCTION FOR TOOL SWITCHING
    // ============================================

    // Global function to refresh all data when tool is loaded
    window.refreshAllData = function () {
        // Check if this is the correct tool to prevent cross-contamination
        if (window.currentTool && window.currentTool.id !== 'nohu-tool') {
            console.log('‚ö†Ô∏è Skipping NOHU refresh - different tool active:', window.currentTool.id);
            return;
        }

        console.log('üîÑ Refreshing all data for NOHU Tool...');

        // Set tool identifier for API calls
        window.currentToolId = 'nohu-tool';

        // Refresh results
        if (window.refreshResults) {
            window.refreshResults();
        }

        // Refresh profiles carousel
        if (typeof loadProfilesCarousel === 'function') {
            loadProfilesCarousel();
        }

        // Refresh automation statuses
        if (typeof loadAutomationStatuses === 'function') {
            loadAutomationStatuses();
        }

        console.log('‚úÖ All data refreshed for NOHU Tool');
    };



    // Load custom sites for NOHU
    function loadCustomSitesForNohu() {
        return JSON.parse(localStorage.getItem('nohu_custom_sites') || '[]');
    }

    // Render NOHU sites dynamically
    async function renderNohuSites() {
        try {
            // Fetch NOHU sites from API
            const response = await fetch('/api/nohu-automation/sites');
            const result = await response.json();

            if (!result.success || !result.data || !result.data.sites) {
                console.error('Failed to load NOHU sites');
                return;
            }

            // Icon mapping for NOHU sites
            const iconMap = {
                'Go99': 'go99',
                'NOHU': 'nohu',
                'TT88': 'tt88',
                'MMOO': 'mmoo',
                '789P': 'p789',
                '33WIN': 'win33',
                '88VV': 'vv88'
            };

            const appSites = result.data.sites.map(site => ({
                name: site.name,
                icon: iconMap[site.name] || 'go99',
                text: site.name.substring(0, 3).toUpperCase()
            }));

            const customSites = loadCustomSitesForNohu();
            const allAppSites = [...appSites, ...customSites.map(s => ({ name: s.name, icon: 'custom', text: s.name.substring(0, 3).toUpperCase() }))];

            // Render App Promo Sites
            const appGrid = document.getElementById('appPromoSites');
            if (appGrid) {
                appGrid.innerHTML = allAppSites.map(site => {
                    const isCustom = customSites.some(s => s.name === site.name);
                    const iconClass = isCustom ? 'site-icon' : `site-icon ${site.icon}`;
                    const iconStyle = isCustom ? 'background-color: #9333ea;' : '';
                    return `
<label class="site-card">
    <input type="checkbox" class="site-check" data-name="${site.name}">
    <div class="${iconClass}" style="${iconStyle}">${site.text}</div>
    <div class="site-name">${site.name}</div>
</label>
`;
                }).join('');
            }

            // Fetch SMS site configs from server (with cache-busting)
            let smsSiteConfigs = {};
            try {
                const timestamp = new Date().getTime();
                const smsConfigResponse = await fetch(`/api/nohu-automation/sms-config?t=${timestamp}`);
                const smsConfigData = await smsConfigResponse.json();
                if (smsConfigData.success) {
                    smsSiteConfigs = smsConfigData.data;
                    console.log('‚úÖ SMS Config loaded:', smsSiteConfigs);
                } else {
                    console.warn('‚ö†Ô∏è SMS Config response not successful:', smsConfigData);
                }
            } catch (err) {
                console.warn('‚ö†Ô∏è Failed to load SMS config:', err);
            }

            console.log('üìä Final smsSiteConfigs:', smsSiteConfigs);

            // Render SMS Promo Sites
            const smsGrid = document.getElementById('smsPromoSites');
            if (smsGrid) {
                smsGrid.innerHTML = allAppSites.map(site => {
                    const isCustom = customSites.some(s => s.name === site.name);
                    const smsConfig = smsSiteConfigs[site.name];
                    const hasSmsUrl = smsConfig && smsConfig.registerSmsUrl !== null && smsConfig.registerSmsUrl !== undefined;
                    console.log(`üì± ${site.name}: hasSmsUrl=${hasSmsUrl}, config=${JSON.stringify(smsConfig)}`);
                    const iconClass = isCustom ? 'site-icon' : `site-icon ${site.icon}`;
                    const iconStyle = isCustom ? 'background-color: #9333ea;' : '';
                    const disabledStyle = !hasSmsUrl ? 'opacity: 0.5; cursor: not-allowed;' : '';
                    const disabledAttr = !hasSmsUrl ? 'disabled' : '';

                    return `
<label class="site-card" style="${disabledStyle}" title="${!hasSmsUrl ? '‚ö†Ô∏è SMS URL ch∆∞a c·∫•u h√¨nh' : ''}">
    <input type="checkbox" class="site-check site-check-sms" data-name="${site.name}-SMS" ${disabledAttr}>
    <div class="${iconClass}" style="${iconStyle}">${site.text}</div>
    <div class="site-name">${site.name}${!hasSmsUrl ? ' ‚ö†Ô∏è' : ''}</div>
</label>
`;
                }).join('');
            }

            console.log(`‚úÖ Rendered ${allAppSites.length} NOHU sites`);
        } catch (error) {
            console.error('‚ùå Error rendering NOHU sites:', error);
        }
    }

    // Initialize sites on page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', renderNohuSites);
    } else {
        // DOM is already loaded
        renderNohuSites();
    }

    console.log('‚úÖ NOHU Tool JavaScript loaded (V2 Design)');
</script>